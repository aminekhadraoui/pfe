{"ast":null,"code":"'use strict';\n\nconst isBrowser = typeof document !== \"undefined\";\n\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n/**\n * Decides if the supplied variable is variant label\n */\n\n\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nconst variantPriorityOrder = [\"animate\", \"whileInView\", \"whileFocus\", \"whileHover\", \"whileTap\", \"whileDrag\", \"exit\"];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));\n}\n\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\nconst featureProps = {\n  animation: [\"animate\", \"variants\", \"whileHover\", \"whileTap\", \"exit\", \"whileInView\", \"whileFocus\", \"whileDrag\"],\n  exit: [\"exit\"],\n  drag: [\"drag\", \"dragControls\"],\n  focus: [\"whileFocus\"],\n  hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n  tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n  pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n  inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n  layout: [\"layout\", \"layoutId\"]\n};\nconst featureDefinitions = {};\n\nfor (const key in featureProps) {\n  featureDefinitions[key] = {\n    isEnabled: props => featureProps[key].some(name => !!props[name])\n  };\n}\n\nconst scaleCorrectors = {};\n\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n/**\n * Generate a list of every possible transform key.\n */\n\n\nconst transformPropOrder = [\"transformPerspective\", \"x\", \"y\", \"z\", \"translateX\", \"translateY\", \"translateZ\", \"scale\", \"scaleX\", \"scaleY\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\"];\n/**\n * A quick lookup for transform props.\n */\n\nconst transformProps = new Set(transformPropOrder);\n\nfunction isForcedMotionValue(key, {\n  layout,\n  layoutId\n}) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\nconst isMotionValue = value => Boolean(value && value.getVelocity);\n\nconst translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(transform, {\n  enableHardwareAcceleration = true,\n  allowTransformNone = true\n}, transformIsDefault, transformTemplate) {\n  // The transform string we're going to build into.\n  let transformString = \"\";\n  /**\n   * Loop over all possible transforms in order, adding the ones that\n   * are present to the transform string.\n   */\n\n  for (let i = 0; i < numTransforms; i++) {\n    const key = transformPropOrder[i];\n\n    if (transform[key] !== undefined) {\n      const transformName = translateAlias[key] || key;\n      transformString += `${transformName}(${transform[key]}) `;\n    }\n  }\n\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n\n  transformString = transformString.trim(); // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n\nconst checkStringStartsWith = token => key => typeof key === \"string\" && key.startsWith(token);\n\nconst isCSSVariableName = checkStringStartsWith(\"--\");\nconst isCSSVariableToken = checkStringStartsWith(\"var(--\");\nconst cssVariableRegex = /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g;\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\nconst getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst number = {\n  test: v => typeof v === \"number\",\n  parse: parseFloat,\n  transform: v => v\n};\nconst alpha = { ...number,\n  transform: v => clamp(0, 1, v)\n};\nconst scale = { ...number,\n  default: 1\n};\n/**\n * TODO: When we move from string as a source of truth to data models\n * everything in this folder should probably be referred to as models vs types\n */\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\n\nconst sanitize = v => Math.round(v * 100000) / 100000;\n\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\n\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\nconst createUnitType = unit => ({\n  test: v => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: v => `${v}${unit}`\n});\n\nconst degrees = createUnitType(\"deg\");\nconst percent = createUnitType(\"%\");\nconst px = createUnitType(\"px\");\nconst vh = createUnitType(\"vh\");\nconst vw = createUnitType(\"vw\");\nconst progressPercentage = { ...percent,\n  parse: v => percent.parse(v) / 100,\n  transform: v => percent.transform(v * 100)\n};\nconst int = { ...number,\n  transform: Math.round\n};\nconst numberValueTypes = {\n  // Border props\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const {\n    style,\n    vars,\n    transform,\n    transformOrigin\n  } = state; // Track whether we encounter any transform or transformOrigin values.\n\n  let hasTransform = false;\n  let hasTransformOrigin = false; // Does the calculated transform essentially equal \"none\"?\n\n  let transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable.\n   *\n   * Transforms and transform origins are kept seperately for further processing.\n   */\n\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    /**\n     * If this is a CSS variable we don't do any further processing.\n     */\n\n    if (isCSSVariableName(key)) {\n      vars[key] = value;\n      continue;\n    } // Convert the value to its default value type, ie 0 -> \"0px\"\n\n\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n\n    if (transformProps.has(key)) {\n      // If this is a transform, flag to enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType; // If we already know we have a non-default transform, early return\n\n      if (!transformIsNone) continue; // Otherwise check to see if this is a default transform\n\n      if (value !== (valueType.default || 0)) transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n\n  if (!latestValues.transform) {\n    if (hasTransform || transformTemplate) {\n      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      /**\n       * If we have previously created a transform but currently don't have any,\n       * reset transform style to none.\n       */\n      style.transform = \"none\";\n    }\n  }\n  /**\n   * Build a transformOrigin style. Uses the same defaults as the browser for\n   * undefined origins.\n   */\n\n\n  if (hasTransformOrigin) {\n    const {\n      originX = \"50%\",\n      originY = \"50%\",\n      originZ = 0\n    } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\nconst dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nconst camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  // Normalise path length by setting SVG attribute pathLength to 1\n  attrs.pathLength = 1; // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n  const keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = px.transform(-offset); // Build the dash array\n\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\n\nfunction buildSVGAttrs(state, {\n  attrX,\n  attrY,\n  attrScale,\n  originX,\n  originY,\n  pathLength,\n  pathSpacing = 1,\n  pathOffset = 0,\n  // This is object creation, which we try to avoid per-frame.\n  ...latest\n}, options, isSVGTag, transformTemplate) {\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  /**\n   * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n   * as normal HTML tags.\n   */\n\n  if (isSVGTag) {\n    if (state.style.viewBox) {\n      state.attrs.viewBox = state.style.viewBox;\n    }\n\n    return;\n  }\n\n  state.attrs = state.style;\n  state.style = {};\n  const {\n    attrs,\n    style,\n    dimensions\n  } = state;\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    if (dimensions) style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Render attrX/attrY/attrScale as attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY;\n  if (attrScale !== undefined) attrs.scale = attrScale; // Build SVG path if one has been defined\n\n  if (pathLength !== undefined) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\nconst isSVGTag = tag => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\n\nconst camelToDash = str => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nfunction renderHTML(element, {\n  style,\n  vars\n}, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp)); // Loop over any CSS variables and assign those.\n\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nconst camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\", \"pathLength\", \"startOffset\", \"textLength\", \"lengthAdjust\"]);\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, undefined, projection);\n\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps) {\n  const {\n    style\n  } = props;\n  const newValues = {};\n\n  for (const key in style) {\n    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props, prevProps) {\n  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);\n\n  for (const key in props) {\n    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n      const targetKey = transformPropOrder.indexOf(key) !== -1 ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1) : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  /**\n   * If the variant definition is a function, resolve.\n   */\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n  }\n  /**\n   * If the variant definition is a variant label, or\n   * the function returned a variant label, resolve.\n   */\n\n\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  /**\n   * At this point we've resolved both functions and variant labels,\n   * but the resolved variant label might itself have been a function.\n   * If so, resolve. This can only have returned a valid target object.\n   */\n\n\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n  }\n\n  return definition;\n}\n\nconst isKeyframesTarget = v => {\n  return Array.isArray(v);\n};\n\nconst isCustomValue = v => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nconst resolveFinalValueInKeyframes = v => {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\n\n\nconst combineFunctions = (a, b) => v => b(a(v));\n\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nfunction createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two arrays, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let toRun = [];\n  let toRunNextFrame = [];\n  /**\n   *\n   */\n\n  let numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive) toKeepAlive.add(callback); // If the buffer doesn't already contain this callback, add it\n\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback); // If we're adding it to the currently running buffer, update its measured size\n\n        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;\n      }\n\n      return callback;\n    },\n\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      const index = toRunNextFrame.indexOf(callback);\n      if (index !== -1) toRunNextFrame.splice(index, 1);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun]; // Clear the next frame list\n\n      toRunNextFrame.length = 0; // Execute this frame\n\n      numToRun = toRun.length;\n\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = toRun[i];\n          callback(frameData);\n\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nconst frameData = {\n  delta: 0,\n  timestamp: 0,\n  isProcessing: false\n};\nconst maxElapsed$1 = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nconst stepsOrder = [\"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nconst steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\n\nconst processStep = stepId => steps[stepId].process(frameData);\n\nconst processFrame = timestamp => {\n  runNextFrame = false;\n  frameData.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed$1), 1);\n  frameData.timestamp = timestamp;\n  frameData.isProcessing = true;\n  stepsOrder.forEach(processStep);\n  frameData.isProcessing = false;\n\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    requestAnimationFrame(processFrame);\n  }\n};\n\nconst startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!frameData.isProcessing) requestAnimationFrame(processFrame);\n};\n\nconst frame = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n\n  acc[key] = (process, keepAlive = false, immediate = false) => {\n    if (!runNextFrame) startLoop();\n    return step.schedule(process, keepAlive, immediate);\n  };\n\n  return acc;\n}, {});\n\nfunction cancelFrame(process) {\n  stepsOrder.forEach(key => steps[key].cancel(process));\n}\n\nconst noop = any => any;\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\n\n\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\n\n\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\n\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\nexports.warning = noop;\nexports.invariant = noop;\n\nif (process.env.NODE_ENV !== \"production\") {\n  exports.warning = (check, message) => {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n\n  exports.invariant = (check, message) => {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nconst secondsToMilliseconds = seconds => seconds * 1000;\n\nconst millisecondsToSeconds = milliseconds => milliseconds / 1000;\n\nconst instantAnimationState = {\n  current: false\n};\n\nconst isBezierDefinition = easing => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nfunction isWaapiSupportedEasing(easing) {\n  return Boolean(!easing || typeof easing === \"string\" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n}\n\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nconst supportedWaapiEasing = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])\n};\n\nfunction mapEasingToNativeEasing(easing) {\n  if (!easing) return undefined;\n  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];\n}\n\nfunction animateStyle(element, valueName, keyframes, {\n  delay = 0,\n  duration,\n  repeat = 0,\n  repeatType = \"loop\",\n  ease,\n  times\n} = {}) {\n  const keyframeOptions = {\n    [valueName]: keyframes\n  };\n  if (times) keyframeOptions.offset = times;\n  const easing = mapEasingToNativeEasing(ease);\n  /**\n   * If this is an easing array, apply to keyframes, not animation as a whole\n   */\n\n  if (Array.isArray(easing)) keyframeOptions.easing = easing;\n  return element.animate(keyframeOptions, {\n    delay,\n    duration,\n    easing: !Array.isArray(easing) ? easing : \"linear\",\n    fill: \"both\",\n    iterations: repeat + 1,\n    direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\"\n  });\n}\n\nconst featureTests = {\n  waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\")\n};\nconst results = {};\nconst supports = {};\n/**\n * Generate features tests that cache their results.\n */\n\nfor (const key in featureTests) {\n  supports[key] = () => {\n    if (results[key] === undefined) results[key] = featureTests[key]();\n    return results[key];\n  };\n}\n\nfunction getFinalKeyframe(keyframes, {\n  repeat,\n  repeatType = \"loop\"\n}) {\n  const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1 ? 0 : keyframes.length - 1;\n  return keyframes[index];\n}\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\n\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\n\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n\n  do {\n    currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - x;\n\n    if (currentX > 0.0) {\n      upperBound = currentT;\n    } else {\n      lowerBound = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n\n  return currentT;\n}\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  // If this is a linear gradient, return linear easing\n  if (mX1 === mY1 && mX2 === mY2) return noop;\n\n  const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2); // If animation is at start/end, return t without easing\n\n\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nconst isEasingArray = ease => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n}; // Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\n\n\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2; // Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\n\n\nconst reverseEasing = easing => p => 1 - easing(1 - p);\n\nconst circIn = p => 1 - Math.sin(Math.acos(p));\n\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nconst anticipate = p => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst easingLookup = {\n  linear: noop,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate\n};\n\nconst easingDefinitionToFunction = definition => {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\n\n\nconst isColorString = (type, testProp) => v => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\n\nconst splitColor = (aName, bName, cName) => v => {\n  if (!isString(v)) return v;\n  const [a, b, c, alpha] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a),\n    [bName]: parseFloat(b),\n    [cName]: parseFloat(c),\n    alpha: alpha !== undefined ? parseFloat(alpha) : 1\n  };\n};\n\nconst clampRgbUnit = v => clamp(0, 255, v);\n\nconst rgbUnit = { ...number,\n  transform: v => Math.round(clampRgbUnit(v))\n};\nconst rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({\n    red,\n    green,\n    blue,\n    alpha: alpha$1 = 1\n  }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\nfunction parseHex(v) {\n  let r = \"\";\n  let g = \"\";\n  let b = \"\";\n  let a = \"\"; // If we have 6 characters, ie #FF0000\n\n  if (v.length > 5) {\n    r = v.substring(1, 3);\n    g = v.substring(3, 5);\n    b = v.substring(5, 7);\n    a = v.substring(7, 9); // Or we have 3 characters, ie #F00\n  } else {\n    r = v.substring(1, 2);\n    g = v.substring(2, 3);\n    b = v.substring(3, 4);\n    a = v.substring(4, 5);\n    r += r;\n    g += g;\n    b += b;\n    a += a;\n  }\n\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: a ? parseInt(a, 16) / 255 : 1\n  };\n}\n\nconst hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\nconst hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({\n    hue,\n    saturation,\n    lightness,\n    alpha: alpha$1 = 1\n  }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\nconst color = {\n  test: v => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: v => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: v => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\n\nconst mix = (from, to, progress) => -progress * from + progress * to + from; // Adapted from https://gist.github.com/mjackson/5311256\n\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nfunction hslaToRgba({\n  hue,\n  saturation,\n  lightness,\n  alpha\n}) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p = 2 * lightness - q;\n    red = hueToRgb(p, q, hue + 1 / 3);\n    green = hueToRgb(p, q, hue);\n    blue = hueToRgb(p, q, hue - 1 / 3);\n  }\n\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha\n  };\n} // Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\n\n\nconst mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\n\nconst colorTypes = [hex, rgba, hsla];\n\nconst getColorType = v => colorTypes.find(type => type.test(v));\n\nfunction asRGBA(color) {\n  const type = getColorType(color);\n  exports.invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n  let model = type.parse(color);\n\n  if (type === hsla) {\n    // TODO Remove this cast - needed since Framer Motion's stricter typing\n    model = hslaToRgba(model);\n  }\n\n  return model;\n}\n\nconst mixColor = (from, to) => {\n  const fromRGBA = asRGBA(from);\n  const toRGBA = asRGBA(to);\n  const blended = { ...fromRGBA\n  };\n  return v => {\n    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n    return rgba.transform(blended);\n  };\n};\n\nfunction test(v) {\n  var _a, _b;\n\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\n\nconst cssVarTokeniser = {\n  regex: cssVariableRegex,\n  countKey: \"Vars\",\n  token: \"${v}\",\n  parse: noop\n};\nconst colorTokeniser = {\n  regex: colorRegex,\n  countKey: \"Colors\",\n  token: \"${c}\",\n  parse: color.parse\n};\nconst numberTokeniser = {\n  regex: floatRegex,\n  countKey: \"Numbers\",\n  token: \"${n}\",\n  parse: number.parse\n};\n\nfunction tokenise(info, {\n  regex,\n  countKey,\n  token,\n  parse\n}) {\n  const matches = info.tokenised.match(regex);\n  if (!matches) return;\n  info[\"num\" + countKey] = matches.length;\n  info.tokenised = info.tokenised.replace(regex, token);\n  info.values.push(...matches.map(parse));\n}\n\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const info = {\n    value: originalValue,\n    tokenised: originalValue,\n    values: [],\n    numVars: 0,\n    numColors: 0,\n    numNumbers: 0\n  };\n  if (info.value.includes(\"var(--\")) tokenise(info, cssVarTokeniser);\n  tokenise(info, colorTokeniser);\n  tokenise(info, numberTokeniser);\n  return info;\n}\n\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  const {\n    values,\n    numColors,\n    numVars,\n    tokenised\n  } = analyseComplexValue(source);\n  const numValues = values.length;\n  return v => {\n    let output = tokenised;\n\n    for (let i = 0; i < numValues; i++) {\n      if (i < numVars) {\n        output = output.replace(cssVarTokeniser.token, v[i]);\n      } else if (i < numVars + numColors) {\n        output = output.replace(colorTokeniser.token, color.transform(v[i]));\n      } else {\n        output = output.replace(numberTokeniser.token, sanitize(v[i]));\n      }\n    }\n\n    return output;\n  };\n}\n\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : v;\n\nfunction getAnimatableNone$1(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone: getAnimatableNone$1\n};\n\nconst mixImmediate = (origin, target) => p => `${p > 0 ? target : origin}`;\n\nfunction getMixer$1(origin, target) {\n  if (typeof origin === \"number\") {\n    return v => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return origin.startsWith(\"var(\") ? mixImmediate(origin, target) : mixComplex(origin, target);\n  }\n}\n\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixObject = (origin, target) => {\n  const output = { ...origin,\n    ...target\n  };\n  const blendValue = {};\n\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer$1(origin[key], target[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.values, targetStats.values), template);\n  } else {\n    exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }\n};\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n\n\nconst progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mixNumber = (from, to) => p => mix(from, to, p);\n\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    return color.test(v) ? mixColor : mixComplex;\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n\n  return mixNumber;\n}\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\n\n\nfunction interpolate(input, output, {\n  clamp: isClamp = true,\n  ease,\n  mixer\n} = {}) {\n  const inputLength = input.length;\n  exports.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n\n  if (inputLength === 1) return () => output[0]; // If input runs highest -> lowest, reverse both arrays\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n\n  const interpolator = v => {\n    let i = 0;\n\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n\n  for (let i = 1; i <= remaining; i++) {\n    const offsetProgress = progress(0, remaining, i);\n    offset.push(mix(min, 1, offsetProgress));\n  }\n}\n\nfunction defaultOffset$1(arr) {\n  const offset = [0];\n  fillOffset(offset, arr.length - 1);\n  return offset;\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map(o => o * duration);\n}\n\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\n\nfunction keyframes({\n  duration = 300,\n  keyframes: keyframeValues,\n  times,\n  ease = \"easeInOut\"\n}) {\n  /**\n   * Easing functions can be externally defined as strings. Here we convert them\n   * into actual functions.\n   */\n  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  const state = {\n    done: false,\n    value: keyframeValues[0]\n  };\n  /**\n   * Create a times array based on the provided 0-1 offsets\n   */\n\n  const absoluteTimes = convertOffsetToTimes( // Only use the provided offsets if they're the correct length\n  // TODO Maybe we should warn here if there's a length mismatch\n  times && times.length === keyframeValues.length ? times : defaultOffset$1(keyframeValues), duration);\n  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)\n  });\n  return {\n    calculatedDuration: duration,\n    next: t => {\n      state.value = mapTimeToKeyframe(t);\n      state.done = t >= duration;\n      return state;\n    }\n  };\n}\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\n\n\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst velocitySampleDuration = 5; // ms\n\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n  const prevT = Math.max(t - velocitySampleDuration, 0);\n  return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration$1 = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\n\nfunction findSpring({\n  duration = 800,\n  bounce = 0.25,\n  velocity = 0,\n  mass = 1\n}) {\n  let envelope;\n  let derivative;\n  exports.warning(duration <= secondsToMilliseconds(maxDuration$1), \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  /**\n   * Restrict dampingRatio and duration to within acceptable ranges.\n   */\n\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));\n\n  if (dampingRatio < 1) {\n    /**\n     * Underdamped spring\n     */\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    /**\n     * Critically-damped spring\n     */\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = secondsToMilliseconds(duration);\n\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\n\nconst rootIterations = 12;\n\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n\n  return result;\n}\n\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  }; // stiffness/damping/mass overrides duration/bounce\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = { ...springOptions,\n      ...derived,\n      velocity: 0.0,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring({\n  keyframes,\n  restDelta,\n  restSpeed,\n  ...options\n}) {\n  const origin = keyframes[0];\n  const target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  const initialDelta = target - origin;\n  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n\n  const isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n  let resolveSpring;\n\n  if (dampingRatio < 1) {\n    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n  } else {\n    // Overdamped spring\n    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n      const freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\n\nfunction inertia({\n  keyframes,\n  velocity = 0.0,\n  power = 0.8,\n  timeConstant = 325,\n  bounceDamping = 10,\n  bounceStiffness = 500,\n  modifyTarget,\n  min,\n  max,\n  restDelta = 0.5,\n  restSpeed\n}) {\n  const origin = keyframes[0];\n  const state = {\n    done: false,\n    value: origin\n  };\n\n  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;\n\n  const nearestBoundary = v => {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n\n  if (target !== ideal) amplitude = target - origin;\n\n  const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);\n\n  const calcLatest = t => target + calcDelta(t);\n\n  const applyFriction = t => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n\n\n  let timeReachedBoundary;\n  let spring$1;\n\n  const checkCatchBoundary = t => {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta,\n      restSpeed\n    });\n  };\n\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: t => {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      let hasUpdatedFrame = false;\n\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n\n\n      if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\n\nconst frameloopDriver = update => {\n  const passTimestamp = ({\n    timestamp\n  }) => update(timestamp);\n\n  return {\n    start: () => frame.update(passTimestamp, true),\n    stop: () => cancelFrame(passTimestamp),\n\n    /**\n     * If we're processing this frame we can use the\n     * framelocked timestamp to keep things in sync.\n     */\n    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()\n  };\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\n\nconst maxGeneratorDuration = 20000;\n\nfunction calcGeneratorDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n\n  while (!state.done && duration < maxGeneratorDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n\n  return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\n\nfunction animateValue({\n  autoplay = true,\n  delay = 0,\n  driver = frameloopDriver,\n  keyframes: keyframes$1,\n  type = \"keyframes\",\n  repeat = 0,\n  repeatDelay = 0,\n  repeatType = \"loop\",\n  onPlay,\n  onStop,\n  onComplete,\n  onUpdate,\n  ...options\n}) {\n  let speed = 1;\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n\n  const updateFinishedPromise = () => {\n    resolveFinishedPromise && resolveFinishedPromise();\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  }; // Create the first finished promise\n\n\n  updateFinishedPromise();\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n\n  let mapNumbersToKeyframes;\n\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n\n  const generator = generatorFactory({ ...options,\n    keyframes: keyframes$1\n  });\n  let mirroredGenerator;\n\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory({ ...options,\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    });\n  }\n\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  let cancelTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calcGeneratorDuration(generator);\n  }\n\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n\n  let currentTime = 0;\n\n  const tick = timestamp => {\n    if (startTime === null) return;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n\n    if (speed > 0) startTime = Math.min(startTime, timestamp);\n\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      currentTime = (timestamp - startTime) * speed;\n    } // Rebase on delay\n\n\n    const timeWithoutDelay = currentTime - delay;\n    const isInDelayPhase = timeWithoutDelay < 0;\n    currentTime = Math.max(timeWithoutDelay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n\n    let elapsed = currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = currentTime / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n\n      const iterationIsOdd = Boolean(currentIteration % 2);\n\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      let p = clamp(0, 1, iterationProgress);\n\n      if (currentTime > totalDuration) {\n        p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n      }\n\n      elapsed = p * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n\n\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes$1[0]\n    } : frameGenerator.next(elapsed);\n\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n\n    let {\n      done\n    } = state;\n\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = currentTime >= totalDuration;\n    }\n\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done || speed < 0 && currentTime <= 0);\n\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n\n    if (isAnimationFinished) {\n      finish();\n    }\n\n    return state;\n  };\n\n  const stopAnimationDriver = () => {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n\n  const cancel = () => {\n    playState = \"idle\";\n    stopAnimationDriver();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n\n  const finish = () => {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    updateFinishedPromise();\n  };\n\n  const play = () => {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime || playState === \"finished\") {\n      startTime = now;\n    }\n\n    cancelTime = startTime;\n    holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n\n    playState = \"running\";\n    animationDriver.start();\n  };\n\n  if (autoplay) {\n    play();\n  }\n\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n\n    get time() {\n      return millisecondsToSeconds(currentTime);\n    },\n\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      currentTime = newTime;\n\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n\n    get duration() {\n      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;\n      return millisecondsToSeconds(duration);\n    },\n\n    get speed() {\n      return speed;\n    },\n\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(currentTime);\n    },\n\n    get state() {\n      return playState;\n    },\n\n    play,\n    pause: () => {\n      playState = \"paused\";\n      holdTime = currentTime;\n    },\n    stop: () => {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      cancel();\n    },\n    cancel: () => {\n      if (cancelTime !== null) tick(cancelTime);\n      cancel();\n    },\n    complete: () => {\n      playState = \"finished\";\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\n/**\n * A list of values that can be hardware-accelerated.\n */\n\n\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\", \"backgroundColor\"]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nconst sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" || valueName === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n\nfunction createAcceleratedAnimation(value, valueName, {\n  onUpdate,\n  onComplete,\n  ...options\n}) {\n  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== \"mirror\" && options.damping !== 0 && options.type !== \"inertia\";\n  if (!canAccelerateAnimation) return false;\n  /**\n   * TODO: Unify with js/index\n   */\n\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  }; // Create the first finished promise\n\n\n  updateFinishedPromise();\n  let {\n    keyframes,\n    duration = 300,\n    ease,\n    times\n  } = options;\n  /**\n   * If this animation needs pre-generated keyframes then generate.\n   */\n\n  if (requiresPregeneratedKeyframes(valueName, options)) {\n    const sampleAnimation = animateValue({ ...options,\n      repeat: 0,\n      delay: 0\n    });\n    let state = {\n      done: false,\n      value: keyframes[0]\n    };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n\n    let t = 0;\n\n    while (!state.done && t < maxDuration) {\n      state = sampleAnimation.sample(t);\n      pregeneratedKeyframes.push(state.value);\n      t += sampleDelta;\n    }\n\n    times = undefined;\n    keyframes = pregeneratedKeyframes;\n    duration = t - sampleDelta;\n    ease = \"linear\";\n  }\n\n  const animation = animateStyle(value.owner.current, valueName, keyframes, { ...options,\n    duration,\n\n    /**\n     * This function is currently not called if ease is provided\n     * as a function so the cast is safe.\n     *\n     * However it would be possible for a future refinement to port\n     * in easing pregeneration from Motion One for browsers that\n     * support the upcoming `linear()` easing function.\n     */\n    ease: ease,\n    times\n  });\n\n  const cancelAnimation = () => animation.cancel();\n\n  const safeCancel = () => {\n    frame.update(cancelAnimation);\n    resolveFinishedPromise();\n    updateFinishedPromise();\n  };\n  /**\n   * Prefer the `onfinish` prop as it's more widely supported than\n   * the `finished` promise.\n   *\n   * Here, we synchronously set the provided MotionValue to the end\n   * keyframe. If we didn't, when the WAAPI animation is finished it would\n   * be removed from the element which would then revert to its old styles.\n   */\n\n\n  animation.onfinish = () => {\n    value.set(getFinalKeyframe(keyframes, options));\n    onComplete && onComplete();\n    safeCancel();\n  };\n  /**\n   * Animation interrupt callback.\n   */\n\n\n  return {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n\n    get time() {\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n\n    set time(newTime) {\n      animation.currentTime = secondsToMilliseconds(newTime);\n    },\n\n    get speed() {\n      return animation.playbackRate;\n    },\n\n    set speed(newSpeed) {\n      animation.playbackRate = newSpeed;\n    },\n\n    get duration() {\n      return millisecondsToSeconds(duration);\n    },\n\n    play: () => {\n      if (hasStopped) return;\n      animation.play();\n      /**\n       * Cancel any pending cancel tasks\n       */\n\n      cancelFrame(cancelAnimation);\n    },\n    pause: () => animation.pause(),\n    stop: () => {\n      hasStopped = true;\n      if (animation.playState === \"idle\") return;\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n\n      const {\n        currentTime\n      } = animation;\n\n      if (currentTime) {\n        const sampleAnimation = animateValue({ ...options,\n          autoplay: false\n        });\n        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n      }\n\n      safeCancel();\n    },\n    complete: () => animation.finish(),\n    cancel: safeCancel\n  };\n}\n\nfunction createInstantAnimation({\n  keyframes,\n  delay,\n  onUpdate,\n  onComplete\n}) {\n  const setValue = () => {\n    onUpdate && onUpdate(keyframes[keyframes.length - 1]);\n    onComplete && onComplete();\n    /**\n     * TODO: As this API grows it could make sense to always return\n     * animateValue. This will be a bigger project as animateValue\n     * is frame-locked whereas this function resolves instantly.\n     * This is a behavioural change and also has ramifications regarding\n     * assumptions within tests.\n     */\n\n    return {\n      time: 0,\n      speed: 1,\n      duration: 0,\n      play: noop,\n      pause: noop,\n      stop: noop,\n      then: resolve => {\n        resolve();\n        return Promise.resolve();\n      },\n      cancel: noop,\n      complete: noop\n    };\n  };\n\n  return delay ? animateValue({\n    keyframes: [0, 1],\n    duration: 0,\n    delay,\n    onComplete: setValue\n  }) : setValue();\n}\n\nconst underDampedSpring = {\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n};\n\nconst criticallyDampedSpring = target => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\n\nconst keyframesTransition = {\n  type: \"keyframes\",\n  duration: 0.8\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\n\nconst ease = {\n  type: \"keyframes\",\n  ease: [0.25, 0.1, 0.35, 1],\n  duration: 0.3\n};\n\nconst getDefaultTransition = (valueKey, {\n  keyframes\n}) => {\n  if (keyframes.length > 2) {\n    return keyframesTransition;\n  } else if (transformProps.has(valueKey)) {\n    return valueKey.startsWith(\"scale\") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;\n  }\n\n  return ease;\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * â: 100, \"100px\", \"#fff\"\n * â: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nconst isAnimatable = (key, value) => {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && ( // It's animatable if we have a string\n  complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\n * Properties that should default to 1 or 100%\n */\n\n\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\n\nfunction applyDefaultFilter(v) {\n  const [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\") return v;\n  const [number] = value.match(floatRegex) || [];\n  if (!number) return v;\n  const unit = value.replace(number, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number !== value) defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\n\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = { ...complex,\n  getAnimatableNone: v => {\n    const functions = v.match(functionRegex);\n    return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n  }\n};\n/**\n * A map of default value types for common values\n */\n\nconst defaultValueTypes = { ...numberValueTypes,\n  // Color props\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n};\n/**\n * Gets the default ValueType for the provided value key\n */\n\nconst getDefaultValueType = key => defaultValueTypes[key];\n\nfunction getAnimatableNone(key, value) {\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter) defaultValueType = complex; // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n\n  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : undefined;\n}\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\n\n\nconst isZeroValueString = v => /^0[^.\\s]+$/.test(v);\n\nfunction isNone(value) {\n  if (typeof value === \"number\") {\n    return value === 0;\n  } else if (value !== null) {\n    return value === \"none\" || value === \"0\" || isZeroValueString(value);\n  }\n}\n\nfunction getKeyframes(value, valueName, target, transition) {\n  const isTargetAnimatable = isAnimatable(valueName, target);\n  let keyframes;\n\n  if (Array.isArray(target)) {\n    keyframes = [...target];\n  } else {\n    keyframes = [null, target];\n  }\n\n  const defaultOrigin = transition.from !== undefined ? transition.from : value.get();\n  let animatableTemplateValue = undefined;\n  const noneKeyframeIndexes = [];\n\n  for (let i = 0; i < keyframes.length; i++) {\n    /**\n     * Fill null/wildcard keyframes\n     */\n    if (keyframes[i] === null) {\n      keyframes[i] = i === 0 ? defaultOrigin : keyframes[i - 1];\n    }\n\n    if (isNone(keyframes[i])) {\n      noneKeyframeIndexes.push(i);\n    } else if (typeof keyframes[i] === \"string\") {\n      animatableTemplateValue = keyframes[i];\n    }\n  }\n\n  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {\n    for (let i = 0; i < noneKeyframeIndexes.length; i++) {\n      const index = noneKeyframeIndexes[i];\n      keyframes[index] = getAnimatableNone(valueName, animatableTemplateValue);\n    }\n  }\n\n  return keyframes;\n}\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\n\n\nfunction isTransitionDefined({\n  when,\n  delay: _delay,\n  delayChildren,\n  staggerChildren,\n  staggerDirection,\n  repeat,\n  repeatType,\n  repeatDelay,\n  from,\n  elapsed,\n  ...transition\n}) {\n  return !!Object.keys(transition).length;\n}\n\nfunction getValueTransition$1(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n  return onComplete => {\n    const valueTransition = getValueTransition$1(transition, valueName) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const keyframes = getKeyframes(value, valueName, target, valueTransition);\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n\n    const originKeyframe = keyframes[0];\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n    exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    let options = {\n      keyframes,\n      velocity: value.getVelocity(),\n      ease: \"easeOut\",\n      ...valueTransition,\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n\n    if (!isTransitionDefined(valueTransition)) {\n      options = { ...options,\n        ...getDefaultTransition(valueName, options)\n      };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n\n    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {\n      /**\n       * If we can't animate this value, or the global instant animation flag is set,\n       * or this is simply defined as an instant transition, return an instant transition.\n       */\n      return createInstantAnimation(options);\n    }\n    /**\n     * Animate via WAAPI if possible.\n     */\n\n\n    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {\n      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n      if (acceleratedAnimation) return acceleratedAnimation;\n    }\n    /**\n     * If we didn't create an accelerated animation, create a JS animation\n     */\n\n\n    return animateValue(options);\n  };\n};\n\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nconst isNumericalString = v => /^\\-?\\d*\\.?\\d+$/.test(v);\n\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1) arr.push(item);\n}\n\nfunction removeItem(arr, item) {\n  const index = arr.indexOf(item);\n  if (index > -1) arr.splice(index, 1);\n} // Adapted from array-move\n\n\nfunction moveItem([...arr], fromIndex, toIndex) {\n  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n\n  if (startIndex >= 0 && startIndex < arr.length) {\n    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n    const [item] = arr.splice(fromIndex, 1);\n    arr.splice(endIndex, 0, item);\n  }\n\n  return arr;\n}\n\nclass SubscriptionManager {\n  constructor() {\n    this.subscriptions = [];\n  }\n\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n\n  notify(a, b, c) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (let i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        const handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  }\n\n  getSize() {\n    return this.subscriptions.length;\n  }\n\n  clear() {\n    this.subscriptions.length = 0;\n  }\n\n}\n\nconst warned = new Set();\n\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message)) return;\n  console.warn(message);\n  if (element) console.warn(element);\n  warned.add(message);\n}\n\nconst isFloat = value => {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nclass MotionValue {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  constructor(init, options = {}) {\n    /**\n     * This will be replaced by the build step with the latest version number.\n     * When MotionValues are provided to motion components, warn if versions are mixed.\n     */\n    this.version = \"10.12.10\";\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n\n    this.events = {};\n\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v; // Update timestamp\n\n      const {\n        delta,\n        timestamp\n      } = frameData;\n\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        frame.postRender(this.scheduleVelocityCheck);\n      } // Update update subscribers\n\n\n      if (this.prev !== this.current && this.events.change) {\n        this.events.change.notify(this.current);\n      } // Update velocity subscribers\n\n\n      if (this.events.velocityChange) {\n        this.events.velocityChange.notify(this.getVelocity());\n      } // Update render subscribers\n\n\n      if (render && this.events.renderRequest) {\n        this.events.renderRequest.notify(this.current);\n      }\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = ({\n      timestamp\n    }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n\n        if (this.events.velocityChange) {\n          this.events.velocityChange.notify(this.getVelocity());\n        }\n      }\n    };\n\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n    this.owner = options.owner;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n\n\n  onChange(subscription) {\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n\n    return this.on(\"change\", subscription);\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n\n    const unsubscribe = this.events[eventName].add(callback);\n\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        /**\n         * If we have no more change listeners by the start\n         * of the next frame, stop active animations.\n         */\n\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n\n    return unsubscribe;\n  }\n\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = prev;\n    this.timeDelta = delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n\n\n  jump(v) {\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.stop();\n    if (this.stopPassiveEffect) this.stopPassiveEffect();\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  get() {\n    return this.current;\n  }\n  /**\n   * @public\n   */\n\n\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  getVelocity() {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  start(startAnimation) {\n    this.stop();\n    return new Promise(resolve => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  isAnimating() {\n    return !!this.animation;\n  }\n\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  destroy() {\n    this.clearListeners();\n    this.stop();\n\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n\n}\n\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\n/**\n * Tests a provided value against a ValueType\n */\n\n\nconst testValueType = v => type => type.test(v);\n/**\n * ValueType for \"auto\"\n */\n\n\nconst auto = {\n  test: v => v === \"auto\",\n  parse: v => v\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\nconst findDimensionValueType = v => dimensionValueTypes.find(testValueType(v));\n/**\n * A list of all ValueTypes\n */\n\n\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\n\nconst findValueType = v => valueTypes.find(testValueType(v));\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\n\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let {\n    transitionEnd = {},\n    transition = {},\n    ...target\n  } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n  target = { ...target,\n    ...transitionEnd\n  };\n\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n\n  const newValueKeys = Object.keys(target).filter(key => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (let i = 0; i < numNewValues; i++) {\n    const key = newValueKeys[i];\n    const targetValue = target[key];\n    let value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value, {\n      owner: visualElement\n    }));\n\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n\n    if (value !== null) visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  const origin = {};\n\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n\n    if (transitionOrigin !== undefined) {\n      origin[key] = transitionOrigin;\n    } else {\n      const value = visualElement.getValue(key);\n\n      if (value) {\n        origin[key] = value.get();\n      }\n    }\n  }\n\n  return origin;\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation({\n  protectedKeys,\n  needsAnimating\n}, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nfunction animateTarget(visualElement, definition, {\n  delay = 0,\n  transitionOverride,\n  type\n} = {}) {\n  let {\n    transition = visualElement.getDefaultTransition(),\n    transitionEnd,\n    ...target\n  } = visualElement.makeTargetAnimatable(definition);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  const animations = [];\n  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];\n\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n\n    const valueTransition = {\n      delay,\n      elapsed: 0,\n      ...transition\n    };\n    /**\n     * If this is the first time a value is being animated, check\n     * to see if we're handling off from an existing animation.\n     */\n\n    if (window.HandoffAppearAnimations && !value.hasAnimated) {\n      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n\n      if (appearId) {\n        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);\n      }\n    }\n\n    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n      type: false\n    } : valueTransition));\n    const animation = value.animation;\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation.then(() => willChange.remove(key));\n    }\n\n    animations.push(animation);\n  }\n\n  if (transitionEnd) {\n    Promise.all(animations).then(() => {\n      transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n  }\n\n  return animations;\n}\n\nconst distance = (a, b) => Math.abs(a - b);\n\nfunction distance2D(a, b) {\n  // Multi-dimensional\n  const xDelta = distance(a.x, b.x);\n  const yDelta = distance(a.y, b.y);\n  return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nconst createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\n\nconst createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\n\nconst createAxis = () => ({\n  min: 0,\n  max: 0\n});\n\nconst createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToBox({\n  top,\n  left,\n  right,\n  bottom\n}) {\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertBoxToBoundingBox({\n  x,\n  y\n}) {\n  return {\n    top: y.min,\n    right: x.max,\n    bottom: y.max,\n    left: x.min\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoxPoints(point, transformPoint) {\n  if (!transformPoint) return point;\n  const topLeft = transformPoint({\n    x: point.left,\n    y: point.top\n  });\n  const bottomRight = transformPoint({\n    x: point.right,\n    y: point.bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\nfunction isIdentityScale(scale) {\n  return scale === undefined || scale === 1;\n}\n\nfunction hasScale({\n  scale,\n  scaleX,\n  scaleY\n}) {\n  return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\n\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\n\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\n\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, {\n  x,\n  y\n}) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  const treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\n     * TODO: Prefer to remove this, but currently we have motion components with\n     * display: contents in Framer.\n     */\n\n    const instance = node.instance;\n\n    if (instance && instance.style && instance.style.display === \"contents\") {\n      continue;\n    }\n\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n      applyBoxDelta(box, delta);\n    }\n\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n   * This will help reduce useless scales getting rendered.\n   */\n\n\n  treeScale.x = snapToDefault(treeScale.x);\n  treeScale.y = snapToDefault(treeScale.y);\n}\n\nfunction snapToDefault(scale) {\n  if (Number.isInteger(scale)) return scale;\n  return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\n\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\nfunction measureViewportBox(instance, transformPoint) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\n\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const {\n    scroll\n  } = rootProjectionNode;\n\n  if (scroll) {\n    translateAxis(viewportBox.x, scroll.offset.x);\n    translateAxis(viewportBox.y, scroll.offset.y);\n  }\n\n  return viewportBox;\n}\n/**\n * Timeout defined in ms\n */\n\n\nfunction delay(callback, timeout) {\n  const start = performance.now();\n\n  const checkElapsed = ({\n    timestamp\n  }) => {\n    const elapsed = timestamp - start;\n\n    if (elapsed >= timeout) {\n      cancelFrame(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n\n  frame.read(checkElapsed, true);\n  return () => cancelFrame(checkElapsed);\n}\n\nfunction resolveElements(elements, scope, selectorCache) {\n  var _a;\n\n  if (typeof elements === \"string\") {\n    let root = document;\n\n    if (scope) {\n      exports.invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n      root = scope.current;\n    }\n\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = root.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  /**\n   * Return an empty array\n   */\n\n\n  return Array.from(elements || []);\n}\n\nconst visualElementStore = new WeakMap();\n\nclass GroupPlaybackControls {\n  constructor(animations) {\n    this.animations = animations.filter(Boolean);\n  }\n\n  then(onResolve, onReject) {\n    return Promise.all(this.animations).then(onResolve).catch(onReject);\n  }\n  /**\n   * TODO: Filter out cancelled or stopped animations before returning\n   */\n\n\n  getAll(propName) {\n    return this.animations[0][propName];\n  }\n\n  setAll(propName, newValue) {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i][propName] = newValue;\n    }\n  }\n\n  get time() {\n    return this.getAll(\"time\");\n  }\n\n  set time(time) {\n    this.setAll(\"time\", time);\n  }\n\n  get speed() {\n    return this.getAll(\"speed\");\n  }\n\n  set speed(speed) {\n    this.setAll(\"speed\", speed);\n  }\n\n  get duration() {\n    let max = 0;\n\n    for (let i = 0; i < this.animations.length; i++) {\n      max = Math.max(max, this.animations[i].duration);\n    }\n\n    return max;\n  }\n\n  runAll(methodName) {\n    this.animations.forEach(controls => controls[methodName]());\n  }\n\n  play() {\n    this.runAll(\"play\");\n  }\n\n  pause() {\n    this.runAll(\"pause\");\n  }\n\n  stop() {\n    this.runAll(\"stop\");\n  }\n\n  cancel() {\n    this.runAll(\"cancel\");\n  }\n\n  complete() {\n    this.runAll(\"complete\");\n  }\n\n}\n\nfunction isDOMKeyframes(keyframes) {\n  return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nfunction isSVGElement(element) {\n  return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  const match = splitCSSVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\n\nconst maxDepth = 4;\n\nfunction getVariableValue(current, element, depth = 1) {\n  exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current); // No CSS variable detected\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariableToken(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, { ...target\n}, transitionEnd) {\n  const element = visualElement.current;\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = { ...transitionEnd\n    };\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.values.forEach(value => {\n    const current = value.get();\n    if (!isCSSVariableToken(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariableToken(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved;\n    if (!transitionEnd) transitionEnd = {}; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target,\n    transitionEnd\n  };\n}\n\nconst positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nconst isPositionalKey = key => positionalKeys.has(key);\n\nconst hasPositionalKey = target => {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nconst isNumOrPxType = v => v === number || v === px;\n\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\n\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, {\n  transform\n}) => {\n  if (transform === \"none\" || !transform) return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\n\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\n\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nconst positionalValues = {\n  // Dimensions\n  width: ({\n    x\n  }, {\n    paddingLeft = \"0\",\n    paddingRight = \"0\"\n  }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({\n    y\n  }, {\n    paddingTop = \"0\",\n    paddingBottom = \"0\"\n  }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, {\n    top\n  }) => parseFloat(top),\n  left: (_bbox, {\n    left\n  }) => parseFloat(left),\n  bottom: ({\n    y\n  }, {\n    top\n  }) => parseFloat(top) + (y.max - y.min),\n  right: ({\n    x\n  }, {\n    left\n  }) => parseFloat(left) + (x.max - x.min),\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const {\n    display\n  } = elementComputedStyle;\n  const origin = {}; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\n   * Record origins before we render and update styles\n   */\n\n\n  changedKeys.forEach(key => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  }); // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(key => {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    const value = visualElement.getValue(key);\n    value && value.jump(origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = { ...target\n  };\n  transitionEnd = { ...transitionEnd\n  };\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n\n      for (let i = fromIndex; i < numKeyframes; i++) {\n        /**\n         * Don't allow wildcard keyframes to be used to detect\n         * a difference in value types.\n         */\n        if (to[i] === null) break;\n\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          exports.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          exports.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        value.jump(to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render(); // Restore scroll position\n\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n\n    return {\n      target: convertedTarget,\n      transitionEnd\n    };\n  } else {\n    return {\n      target,\n      transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target,\n    transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nconst parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n}; // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nconst prefersReducedMotion = {\n  current: null\n};\nconst hasReducedMotionListener = {\n  current: false\n};\n\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser) return;\n\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const {\n    willChange\n  } = next;\n\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      /**\n       * Check the version of the incoming motion value with this version\n       * and warn against mismatches.\n       */\n\n\n      if (process.env.NODE_ENV === \"development\") {\n        warnOnce(nextValue.version === \"10.12.10\", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.12.10 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping from a motion value to a static value,\n       * create a new motion value from that\n       */\n      element.addValue(key, motionValue(nextValue, {\n        owner: element\n      }));\n\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key); // TODO: Only update values that aren't being animated or even looked at\n\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {\n          owner: element\n        }));\n      }\n    }\n  } // Handle removed values\n\n\n  for (const key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n\n  return next;\n}\n\nconst featureNames = Object.keys(featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\nconst numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\n\nclass VisualElement {\n  constructor({\n    parent,\n    props,\n    presenceContext,\n    reducedMotionConfig,\n    visualState\n  }, options = {}) {\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n\n    this.values = new Map();\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n\n    this.propEventSubscriptions = {};\n\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n\n    this.scheduleRender = () => frame.render(this.render, false, true);\n\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = { ...latestValues\n    };\n    this.initialValues = props.initial ? { ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {});\n\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n\n\n  scrapeMotionValuesFromProps(_props, _prevProps) {\n    return {};\n  }\n\n  mount(instance) {\n    this.current = instance;\n    visualElementStore.set(instance, this);\n\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n\n    if (this.parent) this.parent.children.add(this);\n    this.update(this.props, this.presenceContext);\n  }\n\n  unmount() {\n    visualElementStore.delete(this.current);\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent && this.parent.children.delete(this);\n\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n\n    for (const key in this.features) {\n      this.features[key].unmount();\n    }\n\n    this.current = null;\n  }\n\n  bindToMotionValue(key, value) {\n    const valueIsTransform = transformProps.has(key);\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);\n\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n    });\n    const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n\n  loadFeatures({\n    children,\n    ...renderedProps\n  }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n    let ProjectionNodeConstructor;\n    let MeasureLayout;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n\n    if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n      const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n      renderedProps.ignoreStrict ? exports.warning(false, strictMessage) : exports.invariant(false, strictMessage);\n    }\n\n    for (let i = 0; i < numFeatures; i++) {\n      const name = featureNames[i];\n      const {\n        isEnabled,\n        Feature: FeatureConstructor,\n        ProjectionNode,\n        MeasureLayout: MeasureLayoutComponent\n      } = featureDefinitions[name];\n      if (ProjectionNode) ProjectionNodeConstructor = ProjectionNode;\n\n      if (isEnabled(renderedProps)) {\n        if (!this.features[name] && FeatureConstructor) {\n          this.features[name] = new FeatureConstructor(this);\n        }\n\n        if (MeasureLayoutComponent) {\n          MeasureLayout = MeasureLayoutComponent;\n        }\n      }\n    }\n\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n      const {\n        layoutId,\n        layout,\n        drag,\n        dragConstraints,\n        layoutScroll,\n        layoutRoot\n      } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll,\n        layoutRoot\n      });\n    }\n\n    return MeasureLayout;\n  }\n\n  updateFeatures() {\n    for (const key in this.features) {\n      const feature = this.features[key];\n\n      if (feature.isMounted) {\n        feature.update(this.props, this.prevProps);\n      } else {\n        feature.mount();\n        feature.isMounted = true;\n      }\n    }\n  }\n\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n\n\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Make a target animatable by Popmotion. For instance, if we're\n   * trying to animate width from 100px to 100vw we need to measure 100vw\n   * in pixels to determine what we really need to animate to. This is also\n   * pluggable to support Framer's custom value types like Color,\n   * and CSS variables.\n   */\n\n\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n\n\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n\n      const listener = props[\"on\" + key];\n\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n\n\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n\n\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n\n  getVariantContext(startAtParent = false) {\n    if (startAtParent) {\n      return this.parent ? this.parent.getVariantContext() : undefined;\n    }\n\n    if (!this.isControllingVariants) {\n      const context = this.parent ? this.parent.getVariantContext() || {} : {};\n\n      if (this.props.initial !== undefined) {\n        context.initial = this.props.initial;\n      }\n\n      return context;\n    }\n\n    const context = {};\n\n    for (let i = 0; i < numVariantProps; i++) {\n      const name = variantProps[i];\n      const prop = this.props[name];\n\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n\n\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n\n\n  addValue(key, value) {\n    // Remove existing value if it exists\n    if (value !== this.values.get(key)) {\n      this.removeValue(key);\n      this.bindToMotionValue(key, value);\n    }\n\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n\n\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n\n\n  hasValue(key) {\n    return this.values.has(key);\n  }\n\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n\n    let value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n\n\n  readValue(key) {\n    return this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n\n\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n\n\n  getBaseTarget(key) {\n    var _a;\n\n    const {\n      initial\n    } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : undefined;\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n\n\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n\n    return this.events[eventName].add(callback);\n  }\n\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n\n}\n\nclass DOMVisualElement extends VisualElement {\n  sortInstanceNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  }\n\n  getBaseTargetFromProps(props, key) {\n    return props.style ? props.style[key] : undefined;\n  }\n\n  removeValueFromRenderState(key, {\n    vars,\n    style\n  }) {\n    delete vars[key];\n    delete style[key];\n  }\n\n  makeTargetAnimatableFromInstance({\n    transition,\n    transitionEnd,\n    ...target\n  }, {\n    transformValues\n  }, isMounted) {\n    let origin = getOrigin(target, transition || {}, this);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return {\n      transition,\n      transitionEnd,\n      ...target\n    };\n  }\n\n}\n\nclass SVGVisualElement extends DOMVisualElement {\n  constructor() {\n    super(...arguments);\n    this.isSVGTag = false;\n  }\n\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    }\n\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n\n  scrapeMotionValuesFromProps(props, prevProps) {\n    return scrapeMotionValuesFromProps(props, prevProps);\n  }\n\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n  }\n\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n\n  mount(instance) {\n    this.isSVGTag = isSVGTag(instance.tagName);\n    super.mount(instance);\n  }\n\n}\n\nfunction getComputedStyle$1(element) {\n  return window.getComputedStyle(element);\n}\n\nclass HTMLVisualElement extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle$1(instance);\n      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n\n  measureInstanceViewportBox(instance, {\n    transformPagePoint\n  }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n\n  scrapeMotionValuesFromProps(props, prevProps) {\n    return scrapeMotionValuesFromProps$1(props, prevProps);\n  }\n\n  handleChildMotionValue() {\n    if (this.childSubscription) {\n      this.childSubscription();\n      delete this.childSubscription;\n    }\n\n    const {\n      children\n    } = this.props;\n\n    if (isMotionValue(children)) {\n      this.childSubscription = children.on(\"change\", latest => {\n        if (this.current) this.current.textContent = `${latest}`;\n      });\n    }\n  }\n\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n\n}\n\nfunction createVisualElement(element) {\n  const options = {\n    presenceContext: null,\n    props: {},\n    visualState: {\n      renderState: {\n        transform: {},\n        transformOrigin: {},\n        style: {},\n        vars: {},\n        attrs: {}\n      },\n      latestValues: {}\n    }\n  };\n  const node = isSVGElement(element) ? new SVGVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : new HTMLVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n  node.mount(element);\n  visualElementStore.set(element, node);\n}\n\nfunction animateSingleValue(value, keyframes, options) {\n  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n  motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n  return motionValue$1.animation;\n}\n/**\n * Create a progress => progress easing function from a generator.\n */\n\n\nfunction createGeneratorEasing(options, scale = 100) {\n  const generator = spring({\n    keyframes: [0, scale],\n    ...options\n  });\n  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n  return {\n    type: \"keyframes\",\n    ease: progress => generator.next(duration * progress).value / scale,\n    duration: millisecondsToSeconds(duration)\n  };\n}\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\n\n\nfunction calcNextTime(current, next, prev, labels) {\n  var _a;\n\n  if (typeof next === \"number\") {\n    return next;\n  } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n    return Math.max(0, current + parseFloat(next));\n  } else if (next === \"<\") {\n    return prev;\n  } else {\n    return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n  }\n}\n\nconst wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nfunction getEasingForSegment(easing, i) {\n  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n  for (let i = 0; i < sequence.length; i++) {\n    const keyframe = sequence[i];\n\n    if (keyframe.at > startTime && keyframe.at < endTime) {\n      removeItem(sequence, keyframe); // If we remove this item we have to push the pointer back one\n\n      i--;\n    }\n  }\n}\n\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n  /**\n   * Erase every existing value between currentTime and targetTime,\n   * this will essentially splice this timeline into any currently\n   * defined ones.\n   */\n  eraseKeyframes(sequence, startTime, endTime);\n\n  for (let i = 0; i < keyframes.length; i++) {\n    sequence.push({\n      value: keyframes[i],\n      at: mix(startTime, endTime, offset[i]),\n      easing: getEasingForSegment(easing, i)\n    });\n  }\n}\n\nfunction compareByTime(a, b) {\n  if (a.at === b.at) {\n    if (a.value === null) return 1;\n    if (b.value === null) return -1;\n    return 0;\n  } else {\n    return a.at - b.at;\n  }\n}\n\nconst defaultSegmentEasing = \"easeInOut\";\n\nfunction createAnimationsFromSequence(sequence, {\n  defaultTransition = {},\n  ...sequenceTransition\n} = {}, scope) {\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n\n    let [subject, keyframes, transition = {}] = segment;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    let maxDuration = 0;\n\n    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n        delay = 0,\n        times = defaultOffset$1(valueKeyframesAsList),\n        type = \"keyframes\",\n        ...remainingTransition\n      } = valueTransition;\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\n       * Resolve stagger() if defined.\n       */\n\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numElements) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n\n      const numKeyframes = valueKeyframesAsList.length;\n\n      if (numKeyframes <= 2 && type === \"spring\") {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        let absoluteDelta = 100;\n\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n\n        const springTransition = { ...remainingTransition\n        };\n\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      const targetTime = startTime + duration;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n\n\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      /**\n       * Find all the elements specified in the definition and parse value\n       * keyframes from their timeline definitions.\n       */\n      const elements = resolveElements(subject, scope, elementCache);\n      const numElements = elements.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n\n      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const element = elements[elementIndex];\n        const subjectSequence = getSubjectSequence(element, sequences);\n\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n        }\n      }\n\n      prevTime = currentTime;\n      currentTime += maxDuration;\n    }\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = { ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] ? { ...transition,\n    ...transition[key]\n  } : { ...transition\n  };\n}\n\nconst isNumber = keyframe => typeof keyframe === \"number\";\n\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  exports.invariant(Boolean(numElements), \"No valid element provided.\");\n  const animations = [];\n\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    /**\n     * Check each element for an associated VisualElement. If none exists,\n     * we need to create one.\n     */\n\n    if (!visualElementStore.has(element)) {\n      /**\n       * TODO: We only need render-specific parts of the VisualElement.\n       * With some additional work the size of the animate() function\n       * could be reduced significantly.\n       */\n      createVisualElement(element);\n    }\n\n    const visualElement = visualElementStore.get(element);\n    const transition = { ...options\n    };\n    /**\n     * Resolve stagger function if provided.\n     */\n\n    if (typeof transition.delay === \"function\") {\n      transition.delay = transition.delay(i, numElements);\n    }\n\n    animations.push(...animateTarget(visualElement, { ...keyframes,\n      transition\n    }, {}));\n  }\n\n  return new GroupPlaybackControls(animations);\n}\n\nconst isSequence = value => Array.isArray(value) && Array.isArray(value[0]);\n\nfunction animateSequence(sequence, options, scope) {\n  const animations = [];\n  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n  animationDefinitions.forEach(({\n    keyframes,\n    transition\n  }, subject) => {\n    let animation;\n\n    if (isMotionValue(subject)) {\n      animation = animateSingleValue(subject, keyframes.default, transition.default);\n    } else {\n      animation = animateElements(subject, keyframes, transition);\n    }\n\n    animations.push(animation);\n  });\n  return new GroupPlaybackControls(animations);\n}\n\nconst createScopedAnimate = scope => {\n  /**\n   * Implementation\n   */\n  function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n    let animation;\n\n    if (isSequence(valueOrElementOrSequence)) {\n      animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n    } else if (isDOMKeyframes(keyframes)) {\n      animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n    }\n\n    if (scope) {\n      scope.animations.push(animation);\n    }\n\n    return animation;\n  }\n\n  return scopedAnimate;\n};\n\nconst animate = createScopedAnimate();\nconst resizeHandlers = new WeakMap();\nlet observer;\n\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const {\n      inlineSize,\n      blockSize\n    } = borderBoxSize[0];\n    return {\n      width: inlineSize,\n      height: blockSize\n    };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\n\nfunction notifyTarget({\n  target,\n  contentRect,\n  borderBoxSize\n}) {\n  var _a;\n\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach(handler => {\n    handler({\n      target,\n      contentSize: contentRect,\n\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n\n    });\n  });\n}\n\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\n\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\") return;\n  observer = new ResizeObserver(notifyAll);\n}\n\nfunction resizeElement(target, handler) {\n  if (!observer) createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach(element => {\n    let elementHandlers = resizeHandlers.get(element);\n\n    if (!elementHandlers) {\n      elementHandlers = new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach(element => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\n\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach(callback => callback(info));\n  };\n\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\n\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler) createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = undefined;\n    }\n  };\n}\n\nfunction resize(a, b) {\n  return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\n\n\nconst maxElapsed = 50;\n\nconst createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\n\nconst createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\n\nconst keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\n\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const {\n    length,\n    position\n  } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\n\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\n\nfunction calcInset(element, container) {\n  let inset = {\n    x: 0,\n    y: 0\n  };\n  let current = element;\n\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n      const {\n        top,\n        left\n      } = current.getBBox();\n      inset.x += left;\n      inset.y += top;\n      /**\n       * Assign the next parent element as the <svg /> tag.\n       */\n\n      while (current && current.tagName !== \"svg\") {\n        current = current.parentNode;\n      }\n    }\n  }\n\n  return inset;\n}\n\nconst ScrollOffset = {\n  Enter: [[0, 1], [1, 1]],\n  Exit: [[0, 0], [1, 0]],\n  Any: [[1, 0], [0, 1]],\n  All: [[0, 0], [1, 1]]\n};\nconst namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\n\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  /**\n   * If we have this edge defined as a preset, replace the definition\n   * with the numerical value.\n   */\n\n  if (namedEdges[edge] !== undefined) {\n    edge = namedEdges[edge];\n  }\n  /**\n   * Handle unit values\n   */\n\n\n  if (typeof edge === \"string\") {\n    const asNumber = parseFloat(edge);\n\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber;\n    }\n  }\n  /**\n   * If the edge is defined as a number, handle as a progress value.\n   */\n\n\n  if (typeof edge === \"number\") {\n    delta = length * edge;\n  }\n\n  return inset + delta;\n}\n\nconst defaultOffset = [0, 0];\n\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n\n  if (typeof offset === \"number\") {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\nconst point = {\n  x: 0,\n  y: 0\n};\n\nfunction resolveOffsets(container, info, options) {\n  let {\n    offset: offsetDefinition = ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n\n\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nfunction measure(container, target = container, info) {\n  /**\n   * Find inset of target within scrollable container\n   */\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n\n  if (target !== container) {\n    let node = target;\n\n    while (node && node !== container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\n\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  return {\n    measure: () => measure(element, options.target, info),\n    update: time => {\n      updateScrollInfo(element, info, time);\n\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: () => onScroll(info)\n  };\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\n\nconst getEventTarget = element => element === document.documentElement ? window : element;\n\nfunction scroll(onScroll, {\n  container = document.documentElement,\n  ...options\n} = {}) {\n  let containerHandlers = onScrollHandlers.get(container);\n  /**\n   * Get the onScroll handlers for this container.\n   * If one isn't found, create a new one.\n   */\n\n  if (!containerHandlers) {\n    containerHandlers = new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  /**\n   * Create a new onScroll handler for the provided callback.\n   */\n\n\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  /**\n   * Check if there's a scroll event listener for this container.\n   * If not, create one.\n   */\n\n  if (!scrollListeners.has(container)) {\n    const measureAll = () => {\n      for (const handler of containerHandlers) handler.measure();\n    };\n\n    const updateAll = () => {\n      for (const handler of containerHandlers) {\n        handler.update(frameData.timestamp);\n      }\n    };\n\n    const notifyAll = () => {\n      for (const handler of containerHandlers) handler.notify();\n    };\n\n    const listener = () => {\n      frame.read(measureAll, false, true);\n      frame.update(updateAll, false, true);\n      frame.update(notifyAll, false, true);\n    };\n\n    scrollListeners.set(container, listener);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener, {\n      passive: true\n    });\n\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener));\n    }\n\n    target.addEventListener(\"scroll\", listener, {\n      passive: true\n    });\n  }\n\n  const listener = scrollListeners.get(container);\n  frame.read(listener, false, true);\n  return () => {\n    var _a;\n\n    cancelFrame(listener);\n    /**\n     * Check if we even have any handlers for this container.\n     */\n\n    const currentHandlers = onScrollHandlers.get(container);\n    if (!currentHandlers) return;\n    currentHandlers.delete(containerHandler);\n    if (currentHandlers.size) return;\n    /**\n     * If no more handlers, remove the scroll listener too.\n     */\n\n    const scrollListener = scrollListeners.get(container);\n    scrollListeners.delete(container);\n\n    if (scrollListener) {\n      getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n      window.removeEventListener(\"resize\", scrollListener);\n    }\n  };\n}\n\nconst thresholds = {\n  any: 0,\n  all: 1\n};\n\nfunction inView(elementOrSelector, onStart, {\n  root,\n  margin: rootMargin,\n  amount = \"any\"\n} = {}) {\n  const elements = resolveElements(elementOrSelector);\n  const activeIntersections = new WeakMap();\n\n  const onIntersectionChange = entries => {\n    entries.forEach(entry => {\n      const onEnd = activeIntersections.get(entry.target);\n      /**\n       * If there's no change to the intersection, we don't need to\n       * do anything here.\n       */\n\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry);\n\n        if (typeof newOnEnd === \"function\") {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n\n  const observer = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(element => observer.observe(element));\n  return () => observer.disconnect();\n}\n\nfunction getOriginIndex(from, total) {\n  if (from === \"first\") {\n    return 0;\n  } else {\n    const lastIndex = total - 1;\n    return from === \"last\" ? lastIndex : lastIndex / 2;\n  }\n}\n\nfunction stagger(duration = 0.1, {\n  startDelay = 0,\n  from = 0,\n  ease\n} = {}) {\n  return (i, total) => {\n    const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n    const distance = Math.abs(fromIndex - i);\n    let delay = duration * distance;\n\n    if (ease) {\n      const maxDelay = total * duration;\n      const easingFunction = easingDefinitionToFunction(ease);\n      delay = easingFunction(delay / maxDelay) * maxDelay;\n    }\n\n    return startDelay + delay;\n  };\n}\n\nconst isCustomValueType = v => {\n  return typeof v === \"object\" && v.mix;\n};\n\nconst getMixer = v => isCustomValueType(v) ? v.mix : undefined;\n\nfunction transform(...args) {\n  const useImmediate = !Array.isArray(args[0]);\n  const argOffset = useImmediate ? 0 : -1;\n  const inputValue = args[0 + argOffset];\n  const inputRange = args[1 + argOffset];\n  const outputRange = args[2 + argOffset];\n  const options = args[3 + argOffset];\n  const interpolator = interpolate(inputRange, outputRange, {\n    mixer: getMixer(outputRange[0]),\n    ...options\n  });\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\n\n\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\n\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = process => cancelFrame(process);\n\n  return acc;\n}, {});\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.MotionValue = MotionValue;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SubscriptionManager = SubscriptionManager;\nexports.VisualElement = VisualElement;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animate = animate;\nexports.animateMotionValue = animateMotionValue;\nexports.animateSingleValue = animateSingleValue;\nexports.animateStyle = animateStyle;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.anticipate = anticipate;\nexports.applyBoxDelta = applyBoxDelta;\nexports.applyTreeDeltas = applyTreeDeltas;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildHTMLStyles = buildHTMLStyles;\nexports.buildSVGAttrs = buildSVGAttrs;\nexports.buildTransform = buildTransform;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.color = color;\nexports.complex = complex;\nexports.convertBoundingBoxToBox = convertBoundingBoxToBox;\nexports.convertBoxToBoundingBox = convertBoxToBoundingBox;\nexports.createBox = createBox;\nexports.createDelta = createDelta;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.featureDefinitions = featureDefinitions;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.getOrigin = getOrigin;\nexports.getValueTransition = getValueTransition$1;\nexports.has2DTranslate = has2DTranslate;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.hasScale = hasScale;\nexports.hasTransform = hasTransform;\nexports.inView = inView;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isAnimationControls = isAnimationControls;\nexports.isBrowser = isBrowser;\nexports.isCSSVariableName = isCSSVariableName;\nexports.isControllingVariants = isControllingVariants;\nexports.isCustomValue = isCustomValue;\nexports.isForcedMotionValue = isForcedMotionValue;\nexports.isKeyframesTarget = isKeyframesTarget;\nexports.isMotionValue = isMotionValue;\nexports.isRefObject = isRefObject;\nexports.isSVGElement = isSVGElement;\nexports.isSVGTag = isSVGTag;\nexports.isVariantLabel = isVariantLabel;\nexports.isVariantNode = isVariantNode;\nexports.measurePageBox = measurePageBox;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.percent = percent;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.progress = progress;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.renderSVG = renderSVG;\nexports.resolveVariant = resolveVariant;\nexports.resolveVariantFromProps = resolveVariantFromProps;\nexports.reverseEasing = reverseEasing;\nexports.scaleCorrectors = scaleCorrectors;\nexports.scalePoint = scalePoint;\nexports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;\nexports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;\nexports.scroll = scroll;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.setValues = setValues;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.steps = steps;\nexports.stepsOrder = stepsOrder;\nexports.sync = sync;\nexports.transform = transform;\nexports.transformBox = transformBox;\nexports.transformProps = transformProps;\nexports.translateAxis = translateAxis;\nexports.variantPriorityOrder = variantPriorityOrder;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;","map":{"version":3,"sources":["C:/Users/HP/Desktop/pfe/node_modules/framer-motion/dist/cjs/index-legacy-a8ebc221.js"],"names":["isBrowser","document","isRefObject","ref","Object","prototype","hasOwnProperty","call","isVariantLabel","v","Array","isArray","isAnimationControls","start","variantPriorityOrder","variantProps","isControllingVariants","props","animate","some","name","isVariantNode","Boolean","variants","featureProps","animation","exit","drag","focus","hover","tap","pan","inView","layout","featureDefinitions","key","isEnabled","scaleCorrectors","addScaleCorrector","correctors","assign","transformPropOrder","transformProps","Set","isForcedMotionValue","layoutId","has","startsWith","undefined","isMotionValue","value","getVelocity","translateAlias","x","y","z","transformPerspective","numTransforms","length","buildTransform","transform","enableHardwareAcceleration","allowTransformNone","transformIsDefault","transformTemplate","transformString","i","transformName","trim","checkStringStartsWith","token","isCSSVariableName","isCSSVariableToken","cssVariableRegex","getValueAsType","type","clamp","min","max","Math","number","test","parse","parseFloat","alpha","scale","default","sanitize","round","floatRegex","colorRegex","singleColorRegex","isString","createUnitType","unit","endsWith","split","degrees","percent","px","vh","vw","progressPercentage","int","numberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","buildHTMLStyles","state","latestValues","options","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","calcOrigin","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","dashKeys","array","camelKeys","buildSVGPath","attrs","spacing","useDashCase","pathLength","keys","pathSpacing","buildSVGAttrs","attrX","attrY","attrScale","pathOffset","latest","isSVGTag","viewBox","tag","toLowerCase","camelToDash","str","replace","renderHTML","element","styleProp","projection","getProjectionStyles","setProperty","camelCaseAttributes","renderSVG","renderState","_styleProp","setAttribute","scrapeMotionValuesFromProps$1","prevProps","newValues","scrapeMotionValuesFromProps","targetKey","indexOf","charAt","toUpperCase","substring","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","isKeyframesTarget","isCustomValue","mix","toValue","resolveFinalValueInKeyframes","combineFunctions","a","b","pipe","transformers","reduce","createRenderStep","runNextFrame","toRun","toRunNextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","addToCurrentFrame","buffer","add","push","cancel","index","splice","delete","process","frameData","delta","timestamp","maxElapsed$1","useDefaultElapsed","stepsOrder","steps","acc","processStep","stepId","processFrame","forEach","requestAnimationFrame","startLoop","frame","cancelFrame","noop","any","getCurrent","visualElement","current","values","get","velocity","resolveVariant","getProps","optimizedAppearDataId","optimizedAppearDataAttribute","exports","warning","invariant","env","NODE_ENV","check","message","console","warn","Error","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","instantAnimationState","isBezierDefinition","easing","isWaapiSupportedEasing","supportedWaapiEasing","every","cubicBezierAsString","c","d","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","mapEasingToNativeEasing","map","animateStyle","valueName","keyframes","delay","duration","repeat","repeatType","times","keyframeOptions","fill","iterations","direction","featureTests","waapi","Element","results","supports","getFinalKeyframe","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","lowerBound","upperBound","mX1","mX2","currentX","currentT","abs","cubicBezier","mY1","mY2","getTForX","aX","isEasingArray","mirrorEasing","p","reverseEasing","sin","acos","circInOut","backInOut","anticipate","pow","easingLookup","easingDefinitionToFunction","x1","y1","x2","y2","isColorString","testProp","splitColor","aName","bName","cName","match","clampRgbUnit","rgbUnit","rgba","red","green","blue","alpha$1","parseHex","r","g","parseInt","hex","hsla","hue","saturation","lightness","color","from","to","progress","hueToRgb","q","hslaToRgba","mixLinearColor","fromExpo","sqrt","colorTypes","getColorType","find","asRGBA","model","mixColor","fromRGBA","toRGBA","blended","_a","_b","isNaN","cssVarTokeniser","regex","countKey","colorTokeniser","numberTokeniser","tokenise","info","matches","tokenised","analyseComplexValue","originalValue","toString","numVars","numColors","numNumbers","includes","parseComplexValue","createTransformer","source","numValues","output","convertNumbersToZero","getAnimatableNone$1","parsed","transformer","complex","getAnimatableNone","mixImmediate","target","getMixer$1","mixComplex","mixArray","blendValue","fromThis","mixObject","template","originStats","targetStats","canInterpolate","toFromDifference","mixNumber","detectMixerFactory","createMixers","customMixer","mixers","mixerFactory","numMixers","mixer","easingFunction","interpolate","input","isClamp","inputLength","reverse","interpolator","progressInRange","fillOffset","remaining","offsetProgress","defaultOffset$1","arr","convertOffsetToTimes","o","defaultEasing","keyframeValues","easingFunctions","done","absoluteTimes","mapTimeToKeyframe","calculatedDuration","next","velocityPerSecond","frameDuration","velocitySampleDuration","calcGeneratorVelocity","resolveValue","prevT","safeMin","minDuration","maxDuration$1","minDamping","maxDamping","findSpring","bounce","mass","envelope","derivative","dampingRatio","undampedFreq","exponentialDecay","calcAngularFreq","exp","e","f","factor","initialGuess","approximateRoot","stiffness","damping","rootIterations","result","durationKeys","physicsKeys","isSpringType","getSpringOptions","springOptions","isResolvedFromDuration","derived","spring","restDelta","restSpeed","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","cos","dampedAngularFreq","freqForT","sinh","cosh","isBelowVelocityThreshold","isBelowDisplacementThreshold","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","isOutOfBounds","nearestBoundary","amplitude","ideal","calcDelta","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","frameloopDriver","update","passTimestamp","stop","now","performance","maxGeneratorDuration","calcGeneratorDuration","generator","timeStep","Infinity","types","decay","tween","animateValue","autoplay","driver","keyframes$1","repeatDelay","onPlay","onStop","onComplete","onUpdate","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","mirroredGenerator","playState","holdTime","startTime","cancelTime","resolvedDuration","totalDuration","currentTime","tick","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","iterationIsOdd","isAnimationFinished","finish","stopAnimationDriver","play","controls","then","reject","time","newTime","newSpeed","pause","complete","sample","acceleratedValues","sampleDelta","maxDuration","requiresPregeneratedKeyframes","createAcceleratedAnimation","canAccelerateAnimation","sampleAnimation","pregeneratedKeyframes","owner","cancelAnimation","safeCancel","onfinish","set","playbackRate","setWithVelocity","createInstantAnimation","setValue","underDampedSpring","criticallyDampedSpring","keyframesTransition","getDefaultTransition","valueKey","isAnimatable","maxDefaults","applyDefaultFilter","slice","defaultValue","functionRegex","filter","functions","join","defaultValueTypes","backgroundColor","outlineColor","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","defaultValueType","isZeroValueString","isNone","getKeyframes","transition","isTargetAnimatable","defaultOrigin","animatableTemplateValue","noneKeyframeIndexes","isTransitionDefined","when","_delay","delayChildren","staggerChildren","staggerDirection","getValueTransition$1","animateMotionValue","valueTransition","originKeyframe","targetKeyframe","isOriginAnimatable","HTMLElement","acceleratedAnimation","isWillChangeMotionValue","isNumericalString","addUniqueItem","item","removeItem","moveItem","fromIndex","toIndex","startIndex","endIndex","SubscriptionManager","constructor","subscriptions","handler","notify","numSubscriptions","getSize","clear","warned","warnOnce","condition","isFloat","MotionValue","init","version","timeDelta","lastUpdated","canTrackVelocity","events","updateAndNotify","render","prev","postRender","scheduleVelocityCheck","change","velocityChange","renderRequest","velocityCheck","hasAnimated","onChange","subscription","on","eventName","unsubscribe","read","clearListeners","eventManagers","attach","passiveEffect","stopPassiveEffect","jump","getPrevious","startAnimation","animationStart","animationComplete","clearAnimation","animationCancel","isAnimating","destroy","motionValue","testValueType","auto","dimensionValueTypes","findDimensionValueType","valueTypes","findValueType","setMotionValue","hasValue","getValue","addValue","setTarget","resolved","transitionEnd","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","variant","getVariant","variantChildren","child","setValues","checkTargetForNewValues","newValueKeys","numNewValues","targetValue","readValue","setBaseTarget","getOriginFromTransition","getOrigin","transitionOrigin","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","transitionOverride","willChange","animations","animationTypeState","animationState","getState","valueTarget","window","HandoffAppearAnimations","appearId","shouldReduceMotion","remove","all","distance2D","xDelta","yDelta","createAxisDelta","translate","originPoint","createDelta","createAxis","createBox","convertBoundingBoxToBox","convertBoxToBoundingBox","transformBoxPoints","point","transformPoint","topLeft","bottomRight","isIdentityScale","hasScale","has2DTranslate","is2DTranslate","scalePoint","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","axis","applyBoxDelta","box","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","projectionDelta","instance","display","layoutScroll","scroll","root","transformBox","snapToDefault","Number","isInteger","translateAxis","transformAxis","transforms","scaleKey","originKey","axisOrigin","xKeys","yKeys","measureViewportBox","getBoundingClientRect","measurePageBox","rootProjectionNode","transformPagePoint","viewportBox","timeout","checkElapsed","resolveElements","elements","scope","selectorCache","querySelectorAll","visualElementStore","WeakMap","GroupPlaybackControls","onResolve","onReject","catch","getAll","propName","setAll","newValue","runAll","methodName","isDOMKeyframes","isSVGElement","SVGElement","tagName","splitCSSVariableRegex","parseCSSVariable","exec","fallback","maxDepth","getVariableValue","depth","getComputedStyle","getPropertyValue","resolveCSSVariables","positionalKeys","isPositionalKey","hasPositionalKey","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","scrollY","pageYOffset","convertedTarget","scrollTo","unitConversion","parseDomVariant","prefersReducedMotion","hasReducedMotionListener","initPrefersReducedMotion","matchMedia","motionMediaQuery","setReducedMotionPreferences","addListener","updateMotionValuesFromProps","nextValue","prevValue","existingValue","latestValue","getStaticValue","removeValue","featureNames","numFeatures","propEventHandlers","numVariantProps","VisualElement","parent","presenceContext","reducedMotionConfig","visualState","children","Map","features","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","triggerBuild","renderInstance","scheduleRender","baseTarget","initialValues","initial","manuallyAnimateOnMount","initialMotionValues","_props","_prevProps","mount","removeFromVariantTree","addVariantChild","bindToMotionValue","unmount","valueIsTransform","removeOnChange","isTransformDirty","removeOnRenderRequest","sortNodePosition","other","sortInstanceNodePosition","loadFeatures","renderedProps","isStrict","preloadedFeatures","initialLayoutGroupConfig","ProjectionNodeConstructor","MeasureLayout","strictMessage","ignoreStrict","Feature","FeatureConstructor","ProjectionNode","MeasureLayoutComponent","dragConstraints","layoutRoot","setOptions","alwaysMeasureLayout","animationType","initialPromotionConfig","updateFeatures","feature","isMounted","build","measureInstanceViewportBox","canMutate","makeTargetAnimatableFromInstance","prevPresenceContext","listener","handleChildMotionValue","getTransformPagePoint","getClosestVariantNode","getVariantContext","startAtParent","context","prop","closestVariantNode","removeValueFromRenderState","readValueFromInstance","getBaseTarget","valueFromInitial","getBaseTargetFromProps","args","DOMVisualElement","compareDocumentPosition","transformValues","SVGVisualElement","arguments","defaultType","getAttribute","getComputedStyle$1","HTMLVisualElement","computedStyle","childSubscription","textContent","createVisualElement","animateSingleValue","motionValue$1","createGeneratorEasing","calcNextTime","labels","wrap","rangeSize","getEasingForSegment","eraseKeyframes","sequence","endTime","keyframe","at","addKeyframes","compareByTime","defaultSegmentEasing","createAnimationsFromSequence","defaultTransition","sequenceTransition","defaultDuration","animationDefinitions","sequences","elementCache","timeLabels","prevTime","segment","subject","resolveValueSequence","valueKeyframes","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","remainingTransition","calculatedDelay","absoluteDelta","isNumberKeyframesArray","springTransition","springEasing","targetTime","remainder","unshift","subjectSequence","getSubjectSequence","getValueSequence","getValueTransition","valueSequences","sort","valueOffset","valueEasing","isNumber","animateElements","elementOrSelector","isSequence","animateSequence","createScopedAnimate","scopedAnimate","valueOrElementOrSequence","resizeHandlers","observer","getElementSize","borderBoxSize","inlineSize","blockSize","getBBox","offsetWidth","offsetHeight","notifyTarget","contentRect","contentSize","notifyAll","entries","createResizeObserver","ResizeObserver","resizeElement","elementHandlers","observe","unobserve","windowCallbacks","windowResizeHandler","createWindowResizeHandler","innerWidth","innerHeight","addEventListener","resizeWindow","resize","maxElapsed","createAxisInfo","scrollLength","targetOffset","targetLength","containerLength","createScrollInfo","position","updateAxisInfo","axisName","updateScrollInfo","calcInset","container","inset","offsetLeft","offsetTop","offsetParent","SVGGraphicsElement","parentNode","ScrollOffset","Enter","Exit","Any","All","namedEdges","center","end","resolveEdge","edge","asNumber","documentElement","clientWidth","clientHeight","defaultOffset","resolveOffset","targetInset","offsetDefinition","targetPoint","containerPoint","resolveOffsets","lengthLabel","targetSize","scrollWidth","scrollHeight","containerSize","hasChanged","numOffsets","interpolatorOffsets","measure","createOnScrollHandler","onScroll","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","containerHandlers","containerHandler","measureAll","updateAll","passive","currentHandlers","scrollListener","removeEventListener","thresholds","onStart","rootMargin","amount","activeIntersections","onIntersectionChange","entry","onEnd","isIntersecting","newOnEnd","IntersectionObserver","threshold","disconnect","getOriginIndex","total","lastIndex","stagger","startDelay","maxDelay","isCustomValueType","getMixer","useImmediate","argOffset","inputValue","inputRange","outputRange","sync","cancelSync"],"mappings":"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","sourcesContent":["'use strict';\n\nconst isBrowser = typeof document !== \"undefined\";\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true, }, transformIsDefault, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        if (transform[key] !== undefined) {\n            const transformName = translateAlias[key] || key;\n            transformString += `${transformName}(${transform[key]}) `;\n        }\n    }\n    if (enableHardwareAcceleration && !transform.z) {\n        transformString += \"translateZ(0)\";\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nconst checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = checkStringStartsWith(\"--\");\nconst isCSSVariableToken = checkStringStartsWith(\"var(--\");\nconst cssVariableRegex = /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g;\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n/**\n * TODO: When we move from string as a source of truth to data models\n * everything in this folder should probably be referred to as models vs types\n */\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n    return typeof v === \"string\";\n}\n\nconst createUnitType = (unit) => ({\n    test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = createUnitType(\"deg\");\nconst percent = createUnitType(\"%\");\nconst px = createUnitType(\"px\");\nconst vh = createUnitType(\"vh\");\nconst vw = createUnitType(\"vw\");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    const { style, vars, transform, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    let transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        const valueType = numberValueTypes[key];\n        const valueAsType = getValueAsType(value, valueType);\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== (valueType.default || 0))\n                transformIsNone = false;\n        }\n        else if (key.startsWith(\"origin\")) {\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n            transformOrigin[key] = valueAsType;\n        }\n        else {\n            style[key] = valueAsType;\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, options, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nconst isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style && isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props, prevProps) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps);\n    for (const key in props) {\n        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\n\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two arrays, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let toRun = [];\n    let toRunNextFrame = [];\n    /**\n     *\n     */\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            // If the buffer doesn't already contain this callback, add it\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                // If we're adding it to the currently running buffer, update its measured size\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            // Clear the next frame list\n            toRunNextFrame.length = 0;\n            // Execute this frame\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nconst frameData = {\n    delta: 0,\n    timestamp: 0,\n    isProcessing: false,\n};\n\nconst maxElapsed$1 = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nconst stepsOrder = [\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => (runNextFrame = true));\n    return acc;\n}, {});\nconst processStep = (stepId) => steps[stepId].process(frameData);\nconst processFrame = (timestamp) => {\n    runNextFrame = false;\n    frameData.delta = useDefaultElapsed\n        ? 1000 / 60\n        : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed$1), 1);\n    frameData.timestamp = timestamp;\n    frameData.isProcessing = true;\n    stepsOrder.forEach(processStep);\n    frameData.isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        requestAnimationFrame(processFrame);\n    }\n};\nconst startLoop = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!frameData.isProcessing)\n        requestAnimationFrame(processFrame);\n};\nconst frame = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n        if (!runNextFrame)\n            startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nfunction cancelFrame(process) {\n    stepsOrder.forEach((key) => steps[key].cancel(process));\n}\n\nconst noop = (any) => any;\n\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    const current = {};\n    visualElement.values.forEach((value, key) => (current[key] = value.get()));\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity(visualElement) {\n    const velocity = {};\n    visualElement.values.forEach((value, key) => (velocity[key] = value.getVelocity()));\n    return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexports.warning = noop;\nexports.invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n    exports.warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    exports.invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nconst instantAnimationState = {\n    current: false,\n};\n\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean(!easing ||\n        (typeof easing === \"string\" && supportedWaapiEasing[easing]) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing) {\n    if (!easing)\n        return undefined;\n    return isBezierDefinition(easing)\n        ? cubicBezierAsString(easing)\n        : Array.isArray(easing)\n            ? easing.map(mapEasingToNativeEasing)\n            : supportedWaapiEasing[easing];\n}\n\nfunction animateStyle(element, valueName, keyframes, { delay = 0, duration, repeat = 0, repeatType = \"loop\", ease, times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n}\n\nconst featureTests = {\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n};\nconst results = {};\nconst supports = {};\n/**\n * Generate features tests that cache their results.\n */\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }) {\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : keyframes.length - 1;\n    return keyframes[index];\n}\n\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||\n        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (!isString(v))\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: isColorString(\"rgb\", \"red\"),\n    parse: splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nconst hsla = {\n    test: isColorString(\"hsl\", \"hue\"),\n    parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    exports.invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Framer Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst cssVarTokeniser = {\n    regex: cssVariableRegex,\n    countKey: \"Vars\",\n    token: \"${v}\",\n    parse: noop,\n};\nconst colorTokeniser = {\n    regex: colorRegex,\n    countKey: \"Colors\",\n    token: \"${c}\",\n    parse: color.parse,\n};\nconst numberTokeniser = {\n    regex: floatRegex,\n    countKey: \"Numbers\",\n    token: \"${n}\",\n    parse: number.parse,\n};\nfunction tokenise(info, { regex, countKey, token, parse }) {\n    const matches = info.tokenised.match(regex);\n    if (!matches)\n        return;\n    info[\"num\" + countKey] = matches.length;\n    info.tokenised = info.tokenised.replace(regex, token);\n    info.values.push(...matches.map(parse));\n}\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const info = {\n        value: originalValue,\n        tokenised: originalValue,\n        values: [],\n        numVars: 0,\n        numColors: 0,\n        numNumbers: 0,\n    };\n    if (info.value.includes(\"var(--\"))\n        tokenise(info, cssVarTokeniser);\n    tokenise(info, colorTokeniser);\n    tokenise(info, numberTokeniser);\n    return info;\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, numVars, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            if (i < numVars) {\n                output = output.replace(cssVarTokeniser.token, v[i]);\n            }\n            else if (i < numVars + numColors) {\n                output = output.replace(colorTokeniser.token, color.transform(v[i]));\n            }\n            else {\n                output = output.replace(numberTokeniser.token, sanitize(v[i]));\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone: getAnimatableNone$1,\n};\n\nconst mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;\nfunction getMixer$1(origin, target) {\n    if (typeof origin === \"number\") {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return origin.startsWith(\"var(\")\n            ? mixImmediate(origin, target)\n            : mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = { ...origin, ...target };\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer$1(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.numVars === targetStats.numVars &&\n        originStats.numColors === targetStats.numColors &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.values, targetStats.values), template);\n    }\n    else {\n        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof v === \"string\") {\n        return color.test(v) ? mixColor : mixComplex;\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \"object\") {\n        return mixObject;\n    }\n    return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    exports.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\n\nfunction defaultOffset$1(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset$1(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration$1 = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    exports.warning(duration <= secondsToMilliseconds(maxDuration$1), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => frameData.isProcessing ? frameData.timestamp : performance.now(),\n    };\n};\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        resolveFinishedPromise && resolveFinishedPromise();\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            currentTime = (timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay;\n        const isInDelayPhase = timeWithoutDelay < 0;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = currentTime >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" ||\n                (playState === \"running\" && done) ||\n                (speed < 0 && currentTime <= 0));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        updateFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    \"backgroundColor\",\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" ||\n    valueName === \"backgroundColor\" ||\n    !isWaapiSupportedEasing(options.ease);\nfunction createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {\n    const canAccelerateAnimation = supports.waapi() &&\n        acceleratedValues.has(valueName) &&\n        !options.repeatDelay &&\n        options.repeatType !== \"mirror\" &&\n        options.damping !== 0 &&\n        options.type !== \"inertia\";\n    if (!canAccelerateAnimation)\n        return false;\n    /**\n     * TODO: Unify with js/index\n     */\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let { keyframes, duration = 300, ease, times } = options;\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n    if (requiresPregeneratedKeyframes(valueName, options)) {\n        const sampleAnimation = animateValue({\n            ...options,\n            repeat: 0,\n            delay: 0,\n        });\n        let state = { done: false, value: keyframes[0] };\n        const pregeneratedKeyframes = [];\n        /**\n         * Bail after 20 seconds of pre-generated keyframes as it's likely\n         * we're heading for an infinite loop.\n         */\n        let t = 0;\n        while (!state.done && t < maxDuration) {\n            state = sampleAnimation.sample(t);\n            pregeneratedKeyframes.push(state.value);\n            t += sampleDelta;\n        }\n        times = undefined;\n        keyframes = pregeneratedKeyframes;\n        duration = t - sampleDelta;\n        ease = \"linear\";\n    }\n    const animation = animateStyle(value.owner.current, valueName, keyframes, {\n        ...options,\n        duration,\n        /**\n         * This function is currently not called if ease is provided\n         * as a function so the cast is safe.\n         *\n         * However it would be possible for a future refinement to port\n         * in easing pregeneration from Motion One for browsers that\n         * support the upcoming `linear()` easing function.\n         */\n        ease: ease,\n        times,\n    });\n    const cancelAnimation = () => animation.cancel();\n    const safeCancel = () => {\n        frame.update(cancelAnimation);\n        resolveFinishedPromise();\n        updateFinishedPromise();\n    };\n    /**\n     * Prefer the `onfinish` prop as it's more widely supported than\n     * the `finished` promise.\n     *\n     * Here, we synchronously set the provided MotionValue to the end\n     * keyframe. If we didn't, when the WAAPI animation is finished it would\n     * be removed from the element which would then revert to its old styles.\n     */\n    animation.onfinish = () => {\n        value.set(getFinalKeyframe(keyframes, options));\n        onComplete && onComplete();\n        safeCancel();\n    };\n    /**\n     * Animation interrupt callback.\n     */\n    return {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(animation.currentTime || 0);\n        },\n        set time(newTime) {\n            animation.currentTime = secondsToMilliseconds(newTime);\n        },\n        get speed() {\n            return animation.playbackRate;\n        },\n        set speed(newSpeed) {\n            animation.playbackRate = newSpeed;\n        },\n        get duration() {\n            return millisecondsToSeconds(duration);\n        },\n        play: () => {\n            if (hasStopped)\n                return;\n            animation.play();\n            /**\n             * Cancel any pending cancel tasks\n             */\n            cancelFrame(cancelAnimation);\n        },\n        pause: () => animation.pause(),\n        stop: () => {\n            hasStopped = true;\n            if (animation.playState === \"idle\")\n                return;\n            /**\n             * WAAPI doesn't natively have any interruption capabilities.\n             *\n             * Rather than read commited styles back out of the DOM, we can\n             * create a renderless JS animation and sample it twice to calculate\n             * its current value, \"previous\" value, and therefore allow\n             * Motion to calculate velocity for any subsequent animation.\n             */\n            const { currentTime } = animation;\n            if (currentTime) {\n                const sampleAnimation = animateValue({\n                    ...options,\n                    autoplay: false,\n                });\n                value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n            }\n            safeCancel();\n        },\n        complete: () => animation.finish(),\n        cancel: safeCancel,\n    };\n}\n\nfunction createInstantAnimation({ keyframes, delay, onUpdate, onComplete, }) {\n    const setValue = () => {\n        onUpdate && onUpdate(keyframes[keyframes.length - 1]);\n        onComplete && onComplete();\n        /**\n         * TODO: As this API grows it could make sense to always return\n         * animateValue. This will be a bigger project as animateValue\n         * is frame-locked whereas this function resolves instantly.\n         * This is a behavioural change and also has ramifications regarding\n         * assumptions within tests.\n         */\n        return {\n            time: 0,\n            speed: 1,\n            duration: 0,\n            play: (noop),\n            pause: (noop),\n            stop: (noop),\n            then: (resolve) => {\n                resolve();\n                return Promise.resolve();\n            },\n            cancel: (noop),\n            complete: (noop),\n        };\n    };\n    return delay\n        ? animateValue({\n            keyframes: [0, 1],\n            duration: 0,\n            delay,\n            onComplete: setValue,\n        })\n        : setValue();\n}\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * â: 100, \"100px\", \"#fff\"\n * â: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (key, value) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n}\n\nfunction getKeyframes(value, valueName, target, transition) {\n    const isTargetAnimatable = isAnimatable(valueName, target);\n    let keyframes;\n    if (Array.isArray(target)) {\n        keyframes = [...target];\n    }\n    else {\n        keyframes = [null, target];\n    }\n    const defaultOrigin = transition.from !== undefined ? transition.from : value.get();\n    let animatableTemplateValue = undefined;\n    const noneKeyframeIndexes = [];\n    for (let i = 0; i < keyframes.length; i++) {\n        /**\n         * Fill null/wildcard keyframes\n         */\n        if (keyframes[i] === null) {\n            keyframes[i] = i === 0 ? defaultOrigin : keyframes[i - 1];\n        }\n        if (isNone(keyframes[i])) {\n            noneKeyframeIndexes.push(i);\n        }\n        else if (typeof keyframes[i] === \"string\") {\n            animatableTemplateValue = keyframes[i];\n        }\n    }\n    if (isTargetAnimatable &&\n        noneKeyframeIndexes.length &&\n        animatableTemplateValue) {\n        for (let i = 0; i < noneKeyframeIndexes.length; i++) {\n            const index = noneKeyframeIndexes[i];\n            keyframes[index] = getAnimatableNone(valueName, animatableTemplateValue);\n        }\n    }\n    return keyframes;\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\nfunction getValueTransition$1(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition$1(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ease: \"easeOut\",\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(options);\n        }\n        /**\n         * Animate via WAAPI if possible.\n         */\n        if (value.owner &&\n            value.owner.current instanceof HTMLElement &&\n            !value.owner.getProps().onUpdate) {\n            const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n            if (acceleratedAnimation)\n                return acceleratedAnimation;\n        }\n        /**\n         * If we didn't create an accelerated animation, create a JS animation\n         */\n        return animateValue(options);\n    };\n};\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = \"10.12.10\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            this.prev = this.current;\n            this.current = v;\n            // Update timestamp\n            const { delta, timestamp } = frameData;\n            if (this.lastUpdated !== timestamp) {\n                this.timeDelta = delta;\n                this.lastUpdated = timestamp;\n                frame.postRender(this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (this.prev !== this.current && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update velocity subscribers\n            if (this.events.velocityChange) {\n                this.events.velocityChange.notify(this.getVelocity());\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = ({ timestamp }) => {\n            if (timestamp !== this.lastUpdated) {\n                this.prev = this.current;\n                if (this.events.velocityChange) {\n                    this.events.velocityChange.notify(this.getVelocity());\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n        this.owner = options.owner;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = prev;\n        this.timeDelta = delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b;\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n    const numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (let i = 0; i < numNewValues; i++) {\n        const key = newValueKeys[i];\n        const targetValue = target[key];\n        let value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value, { owner: visualElement }));\n        if (origin[key] === undefined) {\n            origin[key] = value;\n        }\n        if (value !== null)\n            visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    const origin = {};\n    for (const key in target) {\n        const transitionOrigin = getOriginFromTransition(key, transition);\n        if (transitionOrigin !== undefined) {\n            origin[key] = transitionOrigin;\n        }\n        else {\n            const value = visualElement.getValue(key);\n            if (value) {\n                origin[key] = value.get();\n            }\n        }\n    }\n    return origin;\n}\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = { delay, elapsed: 0, ...transition };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        if (window.HandoffAppearAnimations && !value.hasAnimated) {\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n            if (appearId) {\n                valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);\n            }\n        }\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\n            ? { type: false }\n            : valueTransition));\n        const animation = value.animation;\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            transitionEnd && setTarget(visualElement, transitionEnd);\n        });\n    }\n    return animations;\n}\n\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const instance = node.instance;\n        if (instance &&\n            instance.style &&\n            instance.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    treeScale.x = snapToDefault(treeScale.x);\n    treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n    if (Number.isInteger(scale))\n        return scale;\n    return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n    const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    const originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = performance.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            exports.invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nconst visualElementStore = new WeakMap();\n\nclass GroupPlaybackControls {\n    constructor(animations) {\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    stop() {\n        this.runAll(\"stop\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nfunction isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token, fallback] = match;\n    return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariableToken(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\n    const element = visualElement.current;\n    if (!(element instanceof Element))\n        return { target, transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = { ...transitionEnd };\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.values.forEach((value) => {\n        const current = value.get();\n        if (!isCSSVariableToken(current))\n            return;\n        const resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (const key in target) {\n        const current = target[key];\n        if (!isCSSVariableToken(current))\n            continue;\n        const resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        if (!transitionEnd)\n            transitionEnd = {};\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target, transitionEnd };\n}\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nconst isPositionalKey = (key) => positionalKeys.has(key);\nconst hasPositionalKey = (target) => {\n    return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n    const originBbox = visualElement.measureViewportBox();\n    const element = visualElement.current;\n    const elementComputedStyle = getComputedStyle(element);\n    const { display } = elementComputedStyle;\n    const origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach((key) => {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    const targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach((key) => {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        const value = visualElement.getValue(key);\n        value && value.jump(origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n    target = { ...target };\n    transitionEnd = { ...transitionEnd };\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    let removedTransformValues = [];\n    let hasAttemptedToRemoveTransformValues = false;\n    const changedValueTypeKeys = [];\n    targetPositionalKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        let from = origin[key];\n        let fromType = findDimensionValueType(from);\n        const to = target[key];\n        let toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            const numKeyframes = to.length;\n            const fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (let i = fromIndex; i < numKeyframes; i++) {\n                /**\n                 * Don't allow wildcard keyframes to be used to detect\n                 * a difference in value types.\n                 */\n                if (to[i] === null)\n                    break;\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    exports.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    exports.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                const current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                value.jump(to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(([key, value]) => {\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        // Restore scroll position\n        if (isBrowser && scrollY !== null) {\n            window.scrollTo({ top: scrollY });\n        }\n        return { target: convertedTarget, transitionEnd };\n    }\n    else {\n        return { target, transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target, transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nconst parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n    const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    const { willChange } = next;\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.add(key);\n            }\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"10.12.10\", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.12.10 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.remove(key);\n            }\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nconst featureNames = Object.keys(featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\nconst numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    constructor({ parent, props, presenceContext, reducedMotionConfig, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.scheduleRender = () => frame.render(this.render, false, true);\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n                if (isWillChangeMotionValue(willChange)) {\n                    willChange.add(key);\n                }\n            }\n        }\n    }\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps) {\n        return {};\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            this.features[key].unmount();\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate &&\n                frame.update(this.notifyUpdate, false, true);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n        let ProjectionNodeConstructor;\n        let MeasureLayout;\n        /**\n         * If we're in development mode, check to make sure we're not rendering a motion component\n         * as a child of LazyMotion, as this will break the file-size benefits of using it.\n         */\n        if (process.env.NODE_ENV !== \"production\" &&\n            preloadedFeatures &&\n            isStrict) {\n            const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n            renderedProps.ignoreStrict\n                ? exports.warning(false, strictMessage)\n                : exports.invariant(false, strictMessage);\n        }\n        for (let i = 0; i < numFeatures; i++) {\n            const name = featureNames[i];\n            const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent, } = featureDefinitions[name];\n            if (ProjectionNode)\n                ProjectionNodeConstructor = ProjectionNode;\n            if (isEnabled(renderedProps)) {\n                if (!this.features[name] && FeatureConstructor) {\n                    this.features[name] = new FeatureConstructor(this);\n                }\n                if (MeasureLayoutComponent) {\n                    MeasureLayout = MeasureLayoutComponent;\n                }\n            }\n        }\n        if (!this.projection && ProjectionNodeConstructor) {\n            this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n            const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = renderedProps;\n            this.projection.setOptions({\n                layoutId,\n                layout,\n                alwaysMeasureLayout: Boolean(drag) ||\n                    (dragConstraints && isRefObject(dragConstraints)),\n                visualElement: this,\n                scheduleRender: () => this.scheduleRender(),\n                /**\n                 * TODO: Update options in an effect. This could be tricky as it'll be too late\n                 * to update by the time layout animations run.\n                 * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n                 * ensuring it gets called if there's no potential layout animations.\n                 *\n                 */\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                initialPromotionConfig: initialLayoutGroupConfig,\n                layoutScroll,\n                layoutRoot,\n            });\n        }\n        return MeasureLayout;\n    }\n    updateFeatures() {\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature.isMounted) {\n                feature.update(this.props, this.prevProps);\n            }\n            else {\n                feature.mount();\n                feature.isMounted = true;\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.options, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Make a target animatable by Popmotion. For instance, if we're\n     * trying to animate width from 100px to 100vw we need to measure 100vw\n     * in pixels to determine what we really need to animate to. This is also\n     * pluggable to support Framer's custom value types like Color,\n     * and CSS variables.\n     */\n    makeTargetAnimatable(target, canMutate = true) {\n        return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listener = props[\"on\" + key];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    getVariantContext(startAtParent = false) {\n        if (startAtParent) {\n            return this.parent ? this.parent.getVariantContext() : undefined;\n        }\n        if (!this.isControllingVariants) {\n            const context = this.parent\n                ? this.parent.getVariantContext() || {}\n                : {};\n            if (this.props.initial !== undefined) {\n                context.initial = this.props.initial;\n            }\n            return context;\n        }\n        const context = {};\n        for (let i = 0; i < numVariantProps; i++) {\n            const name = variantProps[i];\n            const prop = this.props[name];\n            if (isVariantLabel(prop) || prop === false) {\n                context[name] = prop;\n            }\n        }\n        return context;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        if (value !== this.values.get(key)) {\n            this.removeValue(key);\n            this.bindToMotionValue(key, value);\n        }\n        this.values.set(key, value);\n        this.latestValues[key] = value.get();\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key) {\n        return this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.readValueFromInstance(this.current, key, this.options);\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\"\n            ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key]\n            : undefined;\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nclass DOMVisualElement extends VisualElement {\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style ? props.style[key] : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {\n        let origin = getOrigin(target, transition || {}, this);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(this, target, origin);\n            const parsed = parseDomVariant(this, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    }\n}\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.isSVGTag = false;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    measureInstanceViewportBox() {\n        return createBox();\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps(props, prevProps);\n    }\n    build(renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle$1(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, options, props) {\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps$1(props, prevProps);\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current)\n                    this.current.textContent = `${latest}`;\n            });\n        }\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderHTML(instance, renderState, styleProp, projection);\n    }\n}\n\nfunction createVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element)\n        ? new SVGVisualElement(options, {\n            enableHardwareAcceleration: false,\n        })\n        : new HTMLVisualElement(options, {\n            enableHardwareAcceleration: true,\n        });\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n    const generator = spring({ keyframes: [0, scale], ...options });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nfunction compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    exports.invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        /**\n         * Check each element for an associated VisualElement. If none exists,\n         * we need to create one.\n         */\n        if (!visualElementStore.has(element)) {\n            /**\n             * TODO: We only need render-specific parts of the VisualElement.\n             * With some additional work the size of the animate() function\n             * could be reduced significantly.\n             */\n            createVisualElement(element);\n        }\n        const visualElement = visualElementStore.get(element);\n        const transition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof transition.delay === \"function\") {\n            transition.delay = transition.delay(i, numElements);\n        }\n        animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n    }\n    return new GroupPlaybackControls(animations);\n}\nconst isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        let animation;\n        if (isMotionValue(subject)) {\n            animation = animateSingleValue(subject, keyframes.default, transition.default);\n        }\n        else {\n            animation = animateElements(subject, keyframes, transition);\n        }\n        animations.push(animation);\n    });\n    return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = (scope) => {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n        let animation;\n        if (isSequence(valueOrElementOrSequence)) {\n            animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n        }\n        else if (isDOMKeyframes(keyframes)) {\n            animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n        }\n        else {\n            animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n};\nconst animate = createScopedAnimate();\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nfunction calcInset(element, container) {\n    let inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current instanceof SVGGraphicsElement && \"getBBox\" in current) {\n            const { top, left } = current.getBBox();\n            inset.x += left;\n            inset.y += top;\n            /**\n             * Assign the next parent element as the <svg /> tag.\n             */\n            while (current && current.tagName !== \"svg\") {\n                current = current.parentNode;\n            }\n        }\n    }\n    return inset;\n}\n\nconst ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scroll(onScroll, { container = document.documentElement, ...options } = {}) {\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers)\n                handler.measure();\n        };\n        const updateAll = () => {\n            for (const handler of containerHandlers) {\n                handler.update(frameData.timestamp);\n            }\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        const listener = () => {\n            frame.read(measureAll, false, true);\n            frame.update(updateAll, false, true);\n            frame.update(notifyAll, false, true);\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        var _a;\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nconst thresholds = {\n    any: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nfunction getOriginIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {\n    return (i, total) => {\n        const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (ease) {\n            const maxDelay = total * duration;\n            const easingFunction = easingDefinitionToFunction(ease);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return startDelay + delay;\n    };\n}\n\nconst isCustomValueType = (v) => {\n    return typeof v === \"object\" && v.mix;\n};\nconst getMixer = (v) => (isCustomValueType(v) ? v.mix : undefined);\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, {\n        mixer: getMixer(outputRange[0]),\n        ...options,\n    });\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = (process) => cancelFrame(process);\n    return acc;\n}, {});\n\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.MotionValue = MotionValue;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SubscriptionManager = SubscriptionManager;\nexports.VisualElement = VisualElement;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animate = animate;\nexports.animateMotionValue = animateMotionValue;\nexports.animateSingleValue = animateSingleValue;\nexports.animateStyle = animateStyle;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.anticipate = anticipate;\nexports.applyBoxDelta = applyBoxDelta;\nexports.applyTreeDeltas = applyTreeDeltas;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildHTMLStyles = buildHTMLStyles;\nexports.buildSVGAttrs = buildSVGAttrs;\nexports.buildTransform = buildTransform;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.color = color;\nexports.complex = complex;\nexports.convertBoundingBoxToBox = convertBoundingBoxToBox;\nexports.convertBoxToBoundingBox = convertBoxToBoundingBox;\nexports.createBox = createBox;\nexports.createDelta = createDelta;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.featureDefinitions = featureDefinitions;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.getOrigin = getOrigin;\nexports.getValueTransition = getValueTransition$1;\nexports.has2DTranslate = has2DTranslate;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.hasScale = hasScale;\nexports.hasTransform = hasTransform;\nexports.inView = inView;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isAnimationControls = isAnimationControls;\nexports.isBrowser = isBrowser;\nexports.isCSSVariableName = isCSSVariableName;\nexports.isControllingVariants = isControllingVariants;\nexports.isCustomValue = isCustomValue;\nexports.isForcedMotionValue = isForcedMotionValue;\nexports.isKeyframesTarget = isKeyframesTarget;\nexports.isMotionValue = isMotionValue;\nexports.isRefObject = isRefObject;\nexports.isSVGElement = isSVGElement;\nexports.isSVGTag = isSVGTag;\nexports.isVariantLabel = isVariantLabel;\nexports.isVariantNode = isVariantNode;\nexports.measurePageBox = measurePageBox;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.percent = percent;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.progress = progress;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.renderSVG = renderSVG;\nexports.resolveVariant = resolveVariant;\nexports.resolveVariantFromProps = resolveVariantFromProps;\nexports.reverseEasing = reverseEasing;\nexports.scaleCorrectors = scaleCorrectors;\nexports.scalePoint = scalePoint;\nexports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;\nexports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;\nexports.scroll = scroll;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.setValues = setValues;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.steps = steps;\nexports.stepsOrder = stepsOrder;\nexports.sync = sync;\nexports.transform = transform;\nexports.transformBox = transformBox;\nexports.transformProps = transformProps;\nexports.translateAxis = translateAxis;\nexports.variantPriorityOrder = variantPriorityOrder;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;\n"]},"metadata":{},"sourceType":"script"}