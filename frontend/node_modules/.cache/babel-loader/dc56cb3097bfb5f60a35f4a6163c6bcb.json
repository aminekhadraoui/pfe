{"ast":null,"code":"// src/anatomy.ts\nfunction anatomy(name, map = {}) {\n  let called = false;\n\n  function assert() {\n    if (!called) {\n      called = true;\n      return;\n    }\n\n    throw new Error(\"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\");\n  }\n\n  function parts(...values) {\n    assert();\n\n    for (const part of values) {\n      ;\n      map[part] = toPart(part);\n    }\n\n    return anatomy(name, map);\n  }\n\n  function extend(...parts2) {\n    for (const part of parts2) {\n      if (part in map) continue;\n      map[part] = toPart(part);\n    }\n\n    return anatomy(name, map);\n  }\n\n  function selectors() {\n    const value = Object.fromEntries(Object.entries(map).map(([key, part]) => [key, part.selector]));\n    return value;\n  }\n\n  function classnames() {\n    const value = Object.fromEntries(Object.entries(map).map(([key, part]) => [key, part.className]));\n    return value;\n  }\n\n  function toPart(part) {\n    const el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [name] : [name, part];\n    const attr = el.filter(Boolean).join(\"__\");\n    const className = `chakra-${attr}`;\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part\n    };\n    return partObj;\n  }\n\n  const __type = {};\n  return {\n    parts,\n    toPart,\n    extend,\n    selectors,\n    classnames,\n\n    get keys() {\n      return Object.keys(map);\n    },\n\n    __type\n  };\n}\n\nexport { anatomy };","map":{"version":3,"sources":["C:/Users/HP/Desktop/pfe/node_modules/@chakra-ui/anatomy/dist/chunk-ZN6IUO2A.mjs"],"names":["anatomy","name","map","called","assert","Error","parts","values","part","toPart","extend","parts2","selectors","value","Object","fromEntries","entries","key","selector","classnames","className","el","includes","attr","filter","Boolean","join","partObj","toString","__type","keys"],"mappings":"AAAA;AACA,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,GAAG,GAAG,EAA7B,EAAiC;AAC/B,MAAIC,MAAM,GAAG,KAAb;;AACA,WAASC,MAAT,GAAkB;AAChB,QAAI,CAACD,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,IAAT;AACA;AACD;;AACD,UAAM,IAAIE,KAAJ,CACJ,qFADI,CAAN;AAGD;;AACD,WAASC,KAAT,CAAe,GAAGC,MAAlB,EAA0B;AACxBH,IAAAA,MAAM;;AACN,SAAK,MAAMI,IAAX,IAAmBD,MAAnB,EAA2B;AACzB;AACAL,MAAAA,GAAG,CAACM,IAAD,CAAH,GAAYC,MAAM,CAACD,IAAD,CAAlB;AACD;;AACD,WAAOR,OAAO,CAACC,IAAD,EAAOC,GAAP,CAAd;AACD;;AACD,WAASQ,MAAT,CAAgB,GAAGC,MAAnB,EAA2B;AACzB,SAAK,MAAMH,IAAX,IAAmBG,MAAnB,EAA2B;AACzB,UAAIH,IAAI,IAAIN,GAAZ,EACE;AACFA,MAAAA,GAAG,CAACM,IAAD,CAAH,GAAYC,MAAM,CAACD,IAAD,CAAlB;AACD;;AACD,WAAOR,OAAO,CAACC,IAAD,EAAOC,GAAP,CAAd;AACD;;AACD,WAASU,SAAT,GAAqB;AACnB,UAAMC,KAAK,GAAGC,MAAM,CAACC,WAAP,CACZD,MAAM,CAACE,OAAP,CAAed,GAAf,EAAoBA,GAApB,CAAwB,CAAC,CAACe,GAAD,EAAMT,IAAN,CAAD,KAAiB,CAACS,GAAD,EAAMT,IAAI,CAACU,QAAX,CAAzC,CADY,CAAd;AAGA,WAAOL,KAAP;AACD;;AACD,WAASM,UAAT,GAAsB;AACpB,UAAMN,KAAK,GAAGC,MAAM,CAACC,WAAP,CACZD,MAAM,CAACE,OAAP,CAAed,GAAf,EAAoBA,GAApB,CAAwB,CAAC,CAACe,GAAD,EAAMT,IAAN,CAAD,KAAiB,CAACS,GAAD,EAAMT,IAAI,CAACY,SAAX,CAAzC,CADY,CAAd;AAGA,WAAOP,KAAP;AACD;;AACD,WAASJ,MAAT,CAAgBD,IAAhB,EAAsB;AACpB,UAAMa,EAAE,GAAG,CAAC,WAAD,EAAc,MAAd,EAAsBC,QAAtB,CAA+Bd,IAAI,IAAI,IAAR,GAAeA,IAAf,GAAsB,EAArD,IAA2D,CAACP,IAAD,CAA3D,GAAoE,CAACA,IAAD,EAAOO,IAAP,CAA/E;AACA,UAAMe,IAAI,GAAGF,EAAE,CAACG,MAAH,CAAUC,OAAV,EAAmBC,IAAnB,CAAwB,IAAxB,CAAb;AACA,UAAMN,SAAS,GAAI,UAASG,IAAK,EAAjC;AACA,UAAMI,OAAO,GAAG;AACdP,MAAAA,SADc;AAEdF,MAAAA,QAAQ,EAAG,IAAGE,SAAU,EAFV;AAGdQ,MAAAA,QAAQ,EAAE,MAAMpB;AAHF,KAAhB;AAKA,WAAOmB,OAAP;AACD;;AACD,QAAME,MAAM,GAAG,EAAf;AACA,SAAO;AACLvB,IAAAA,KADK;AAELG,IAAAA,MAFK;AAGLC,IAAAA,MAHK;AAILE,IAAAA,SAJK;AAKLO,IAAAA,UALK;;AAML,QAAIW,IAAJ,GAAW;AACT,aAAOhB,MAAM,CAACgB,IAAP,CAAY5B,GAAZ,CAAP;AACD,KARI;;AASL2B,IAAAA;AATK,GAAP;AAWD;;AAED,SACE7B,OADF","sourcesContent":["// src/anatomy.ts\nfunction anatomy(name, map = {}) {\n  let called = false;\n  function assert() {\n    if (!called) {\n      called = true;\n      return;\n    }\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\"\n    );\n  }\n  function parts(...values) {\n    assert();\n    for (const part of values) {\n      ;\n      map[part] = toPart(part);\n    }\n    return anatomy(name, map);\n  }\n  function extend(...parts2) {\n    for (const part of parts2) {\n      if (part in map)\n        continue;\n      map[part] = toPart(part);\n    }\n    return anatomy(name, map);\n  }\n  function selectors() {\n    const value = Object.fromEntries(\n      Object.entries(map).map(([key, part]) => [key, part.selector])\n    );\n    return value;\n  }\n  function classnames() {\n    const value = Object.fromEntries(\n      Object.entries(map).map(([key, part]) => [key, part.className])\n    );\n    return value;\n  }\n  function toPart(part) {\n    const el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [name] : [name, part];\n    const attr = el.filter(Boolean).join(\"__\");\n    const className = `chakra-${attr}`;\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part\n    };\n    return partObj;\n  }\n  const __type = {};\n  return {\n    parts,\n    toPart,\n    extend,\n    selectors,\n    classnames,\n    get keys() {\n      return Object.keys(map);\n    },\n    __type\n  };\n}\n\nexport {\n  anatomy\n};\n"]},"metadata":{},"sourceType":"module"}