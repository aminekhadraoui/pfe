{"ast":null,"code":"// src/index.ts\nimport { getActiveElement, getAllFocusable, isTabbable } from \"@chakra-ui/dom-utils\";\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useCallback, useRef } from \"react\";\n\nfunction preventReturnFocus(containerRef) {\n  const el = containerRef.current;\n  if (!el) return false;\n  const activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (el.contains(activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\n\nfunction useFocusOnHide(containerRef, options) {\n  const {\n    shouldFocus: shouldFocusProp,\n    visible,\n    focusRef\n  } = options;\n  const shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(() => {\n    if (!shouldFocus) return;\n\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n\n    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    let rafId;\n\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({\n          preventScroll: true\n        });\n      });\n      return () => {\n        cancelAnimationFrame(rafId);\n      };\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\n\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\n\nfunction useFocusOnShow(target, options = defaultOptions) {\n  const {\n    focusRef,\n    preventScroll,\n    shouldFocus,\n    visible\n  } = options;\n  const element = isRefObject(target) ? target.current : target;\n  const autoFocusValue = shouldFocus && visible;\n  const autoFocusRef = useRef(autoFocusValue);\n  const lastVisibleRef = useRef(visible);\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return;\n    autoFocusRef.current = false;\n    if (element.contains(document.activeElement)) return;\n\n    if (focusRef == null ? void 0 : focusRef.current) {\n      requestAnimationFrame(() => {\n        var _a;\n\n        (_a = focusRef.current) == null ? void 0 : _a.focus({\n          preventScroll\n        });\n      });\n    } else {\n      const tabbableEls = getAllFocusable(element);\n\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({\n            preventScroll\n          });\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  useUpdateEffect(() => {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(element, \"transitionend\", onFocus);\n}\n\nfunction isRefObject(val) {\n  return \"current\" in val;\n}\n\nexport { useFocusOnHide, useFocusOnShow };","map":{"version":3,"sources":["C:/Users/HP/Desktop/pfe/node_modules/@chakra-ui/react-use-focus-effect/dist/index.mjs"],"names":["getActiveElement","getAllFocusable","isTabbable","useEventListener","useSafeLayoutEffect","useUpdateEffect","useCallback","useRef","preventReturnFocus","containerRef","el","current","activeElement","contains","useFocusOnHide","options","shouldFocus","shouldFocusProp","visible","focusRef","rafId","requestAnimationFrame","focus","preventScroll","cancelAnimationFrame","defaultOptions","useFocusOnShow","target","element","isRefObject","autoFocusValue","autoFocusRef","lastVisibleRef","onFocus","document","_a","tabbableEls","length","val"],"mappings":"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","sourcesContent":["// src/index.ts\nimport {\n  getActiveElement,\n  getAllFocusable,\n  isTabbable\n} from \"@chakra-ui/dom-utils\";\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useCallback, useRef } from \"react\";\nfunction preventReturnFocus(containerRef) {\n  const el = containerRef.current;\n  if (!el)\n    return false;\n  const activeElement = getActiveElement(el);\n  if (!activeElement)\n    return false;\n  if (el.contains(activeElement))\n    return false;\n  if (isTabbable(activeElement))\n    return true;\n  return false;\n}\nfunction useFocusOnHide(containerRef, options) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options;\n  const shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(() => {\n    if (!shouldFocus)\n      return;\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    let rafId;\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({ preventScroll: true });\n      });\n      return () => {\n        cancelAnimationFrame(rafId);\n      };\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target, options = defaultOptions) {\n  const { focusRef, preventScroll, shouldFocus, visible } = options;\n  const element = isRefObject(target) ? target.current : target;\n  const autoFocusValue = shouldFocus && visible;\n  const autoFocusRef = useRef(autoFocusValue);\n  const lastVisibleRef = useRef(visible);\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current)\n      return;\n    autoFocusRef.current = false;\n    if (element.contains(document.activeElement))\n      return;\n    if (focusRef == null ? void 0 : focusRef.current) {\n      requestAnimationFrame(() => {\n        var _a;\n        (_a = focusRef.current) == null ? void 0 : _a.focus({ preventScroll });\n      });\n    } else {\n      const tabbableEls = getAllFocusable(element);\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({ preventScroll });\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  useUpdateEffect(() => {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(element, \"transitionend\", onFocus);\n}\nfunction isRefObject(val) {\n  return \"current\" in val;\n}\nexport {\n  useFocusOnHide,\n  useFocusOnShow\n};\n"]},"metadata":{},"sourceType":"module"}